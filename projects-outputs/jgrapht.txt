All Method Calls (2657)

<org.jgrapht.Graph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; org.jgrapht.Graphs; addEdge[org.jgrapht.Graph<V,E>, V, V, double]; E; null; g>
<org.jgrapht.EdgeFactory; createEdge[V, V]; E; org.jgrapht.Graphs; addEdge[org.jgrapht.Graph<V,E>, V, V, double]; E; null; ef>
<java.lang.Object; getClass[]; java.lang.Class<? extends org.jgrapht.Graph>; org.jgrapht.Graphs; addEdge[org.jgrapht.Graph<V,E>, V, V, double]; E; null; g>
<org.jgrapht.WeightedGraph; setEdgeWeight[E, double]; void; org.jgrapht.Graphs; addEdge[org.jgrapht.Graph<V,E>, V, V, double]; E; null; ((WeightedGraph<V,E>)g)>
<org.jgrapht.Graph; addEdge[V, V, E]; boolean; org.jgrapht.Graphs; addEdge[org.jgrapht.Graph<V,E>, V, V, double]; E; null; g>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, V, V]; E; null; g>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, V, V]; E; null; g>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, V, V]; E; null; g>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, E]; boolean; null; sourceGraph>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, E]; boolean; null; sourceGraph>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, E]; boolean; null; targetGraph>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, E]; boolean; null; targetGraph>
<org.jgrapht.Graph; addEdge[V, V, E]; boolean; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, E]; boolean; null; targetGraph>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, V, V, double]; E; null; g>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, V, V, double]; E; null; g>
<org.jgrapht.Graphs; addEdge[org.jgrapht.Graph<V,E>, V, V, double]; E; org.jgrapht.Graphs; addEdgeWithVertices[org.jgrapht.Graph<V,E>, V, V, double]; E; null; this>
<org.jgrapht.Graphs; addAllVertices[org.jgrapht.Graph<? super V,? super >, java.util.Collection<? extends V>]; boolean; org.jgrapht.Graphs; addGraph[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>]; boolean; null; this>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.Graphs; addGraph[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>]; boolean; null; source>
<org.jgrapht.Graphs; addAllEdges[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>, java.util.Collection<? extends E>]; boolean; org.jgrapht.Graphs; addGraph[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>]; boolean; null; this>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.Graphs; addGraph[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>]; boolean; null; source>
<org.jgrapht.Graphs; addAllVertices[org.jgrapht.Graph<? super V,? super >, java.util.Collection<? extends V>]; boolean; org.jgrapht.Graphs; addGraphReversed[org.jgrapht.DirectedGraph<? super V,? super E>, org.jgrapht.DirectedGraph<V,E>]; void; null; this>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.Graphs; addGraphReversed[org.jgrapht.DirectedGraph<? super V,? super E>, org.jgrapht.DirectedGraph<V,E>]; void; null; source>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.Graphs; addGraphReversed[org.jgrapht.DirectedGraph<? super V,? super E>, org.jgrapht.DirectedGraph<V,E>]; void; null; source>
<org.jgrapht.Graph; addEdge[, ]; ; org.jgrapht.Graphs; addGraphReversed[org.jgrapht.DirectedGraph<? super V,? super E>, org.jgrapht.DirectedGraph<V,E>]; void; null; destination>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.Graphs; addGraphReversed[org.jgrapht.DirectedGraph<? super V,? super E>, org.jgrapht.DirectedGraph<V,E>]; void; null; source>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.Graphs; addGraphReversed[org.jgrapht.DirectedGraph<? super V,? super E>, org.jgrapht.DirectedGraph<V,E>]; void; null; source>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.Graphs; addAllEdges[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>, java.util.Collection<? extends E>]; boolean; null; source>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.Graphs; addAllEdges[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>, java.util.Collection<? extends E>]; boolean; null; source>
<org.jgrapht.Graph; addVertex[]; boolean; org.jgrapht.Graphs; addAllEdges[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>, java.util.Collection<? extends E>]; boolean; null; destination>
<org.jgrapht.Graph; addVertex[]; boolean; org.jgrapht.Graphs; addAllEdges[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>, java.util.Collection<? extends E>]; boolean; null; destination>
<org.jgrapht.Graph; addEdge[, , ]; boolean; org.jgrapht.Graphs; addAllEdges[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>, java.util.Collection<? extends E>]; boolean; null; destination>
<org.jgrapht.Graph; addVertex[]; boolean; org.jgrapht.Graphs; addAllVertices[org.jgrapht.Graph<? super V,? super E>, java.util.Collection<? extends V>]; boolean; null; destination>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; null; g>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; null; neighbors>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; null; this>
<org.jgrapht.DirectedGraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.Graphs; predecessorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; null; g>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; predecessorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; null; predecessors>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.Graphs; predecessorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; null; this>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.Graphs; successorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; null; g>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; successorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; null; successors>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.Graphs; successorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.Graphs; testIncidence[org.jgrapht.Graph<V,E>, E, V]; boolean; null; g.getEdgeSource(e)>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.Graphs; testIncidence[org.jgrapht.Graph<V,E>, E, V]; boolean; equals[java.lang.Object]; g>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.Graphs; testIncidence[org.jgrapht.Graph<V,E>, E, V]; boolean; null; g.getEdgeTarget(e)>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.Graphs; testIncidence[org.jgrapht.Graph<V,E>, E, V]; boolean; equals[java.lang.Object]; g>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; null; g>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; null; g>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; null; v>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; null; v>
<org.jgrapht.GraphPath; getGraph[]; org.jgrapht.Graph<V,E>; org.jgrapht.Graphs; getPathVertexList[org.jgrapht.GraphPath<V,E>]; java.util.List<V>; null; path>
<org.jgrapht.GraphPath; getStartVertex[]; V; org.jgrapht.Graphs; getPathVertexList[org.jgrapht.GraphPath<V,E>]; java.util.List<V>; null; path>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; getPathVertexList[org.jgrapht.GraphPath<V,E>]; java.util.List<V>; null; list>
<org.jgrapht.GraphPath; getEdgeList[]; java.util.List<E>; org.jgrapht.Graphs; getPathVertexList[org.jgrapht.GraphPath<V,E>]; java.util.List<V>; null; path>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.Graphs; getPathVertexList[org.jgrapht.GraphPath<V,E>]; java.util.List<V>; null; this>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; getPathVertexList[org.jgrapht.GraphPath<V,E>]; java.util.List<V>; null; list>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; iterator[]; target>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; iter>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<org.jgrapht.VertexFactory; createVertex[]; V; java.lang.Object; createVertex[]; V; null; vertexFactory>
<java.util.Collection; add[V]; boolean; java.lang.Object; createVertex[]; V; null; rim>
<org.jgrapht.generate.RingGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; org.jgrapht.generate.WheelGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; ringGenerator>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.WheelGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.WheelGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.WheelGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.WheelGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.WheelGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.EmptyGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.EmptyGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Set; add[V]; boolean; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; a>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Set; add[V]; boolean; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; b>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; a>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; iterA>
<java.util.Iterator; next[]; V; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; iterA>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; b>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; iterB>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Iterator; next[]; V; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; iterB>
<org.jgrapht.generate.LinearGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; org.jgrapht.generate.RingGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; linearGenerator>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.generate.RingGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; privateMap>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.generate.RingGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; privateMap>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.RingGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<org.jgrapht.generate.RandomGraphGenerator; chooseRandomSeedOnce[]; long; org.jgrapht.generate.RandomGraphGenerator; RandomGraphGenerator[int, int]; void; null; this>
<java.lang.System; nanoTime[]; long; org.jgrapht.generate.RandomGraphGenerator; chooseRandomSeedOnce[]; long; null; System>
<java.util.Random; setSeed[long]; void; org.jgrapht.generate.RandomGraphGenerator; resetRandomSeed[]; void; null; this.randomizer>
<org.jgrapht.generate.RandomGraphGenerator; resetRandomSeed[]; void; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; this>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Map; put[java.lang.Integer, V]; V; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; orderToVertexMap>
<java.lang.Integer; valueOf[int]; java.lang.Integer; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; Integer>
<org.jgrapht.generate.RandomGraphGenerator; edgeTopologyFactoryChooser[org.jgrapht.Graph<V,E>, int]; org.jgrapht.generate.RandomGraphGenerator.EdgeTopologyFactory<V,E>; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; this>
<org.jgrapht.generate.RandomGraphGenerator$EdgeTopologyFactory; isNumberOfEdgesValid[org.jgrapht.Graph<V,E>, int]; boolean; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; edgesFactory>
<java.lang.Object; getClass[]; java.lang.Class<? extends org.jgrapht.Graph>; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<org.jgrapht.generate.RandomGraphGenerator$EdgeTopologyFactory; createEdges[org.jgrapht.Graph<V,E>, java.util.Map<java.lang.Integer,V>, int, java.util.Random]; void; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; edgesFactory>
<java.util.Map; get[java.lang.Object]; VV; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; orderToVertexMap>
<java.lang.Integer; valueOf[int]; java.lang.Integer; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; Integer>
<java.util.Random; nextInt[int]; int; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; randomizer>
<java.util.Map; get[java.lang.Object]; VV; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; orderToVertexMap>
<java.lang.Integer; valueOf[int]; java.lang.Integer; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; Integer>
<java.util.Random; nextInt[int]; int; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; randomizer>
<org.jgrapht.Graph; addEdge[VV, VV]; EE; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; targetGraph>
<org.jgrapht.generate.RandomGraphGenerator$DefaultEdgeTopologyFactory; getMaxEdgesForVertexNum[org.jgrapht.Graph<VV,EE>]; int; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; isNumberOfEdgesValid[org.jgrapht.Graph<VV,EE>, int]; boolean; null; this>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; iterator[]; target>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; slowI>
<java.util.Iterator; next[]; V; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; slowI>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; iterator[]; target>
<java.util.Iterator; next[]; V; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; fastI>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; fastI>
<java.util.Iterator; next[]; V; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; fastI>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Random; nextLong[]; long; org.jgrapht.generate.ScaleFreeGraphGenerator; ScaleFreeGraphGenerator[int]; void; null; random>
<java.util.Random; setSeed[long]; void; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; random>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.List; size[]; int; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexList>
<java.util.Random; nextInt[int]; int; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; random>
<java.util.List; get[int]; java.lang.Integer; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; degrees>
<java.util.List; set[int, java.lang.Integer]; java.lang.Integer; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; degrees>
<java.util.List; get[int]; java.lang.Integer; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; degrees>
<java.util.Random; nextInt[int]; int; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; random>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.List; get[int]; V; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; addEdge[V, V]; vertexList>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.List; get[int]; V; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; addEdge[V, V]; vertexList>
<java.util.List; add[V]; boolean; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexList>
<java.util.List; add[java.lang.Integer]; boolean; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; degrees>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.LinearGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.LinearGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.LinearGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.LinearGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.LinearGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.lang.Math; pow[double, double]; double; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; Math>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertices>
<java.lang.Integer; toBinaryString[int]; java.lang.String; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; Integer>
<java.lang.String; length[]; int; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; s>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.LinkedList; get[int]; V; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; addEdge[V, V]; vertices>
<java.util.LinkedList; get[int]; V; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertices>
<java.util.StringTokenizer; hasMoreTokens[]; boolean; org.jgrapht.experimental.GraphReader; split[java.lang.String]; java.util.List<java.lang.String>; null; tok>
<java.util.List; add[java.lang.String]; boolean; org.jgrapht.experimental.GraphReader; split[java.lang.String]; java.util.List<java.lang.String>; null; l>
<java.util.StringTokenizer; nextToken[]; java.lang.String; org.jgrapht.experimental.GraphReader; split[java.lang.String]; java.util.List<java.lang.String>; null; tok>
<java.io.BufferedReader; ready[]; boolean; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; _in>
<org.jgrapht.experimental.GraphReader; split[java.lang.String]; java.util.List<java.lang.String>; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; this>
<java.io.BufferedReader; readLine[]; java.lang.String; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; _in>
<java.util.List; isEmpty[]; boolean; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; cols>
<java.lang.String; equals[java.lang.Object]; boolean; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; cols.get(0)>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; equals[java.lang.Object]; cols>
<java.lang.String; startsWith[java.lang.String]; boolean; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; cols.get(0)>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; startsWith[java.lang.String]; cols>
<org.jgrapht.experimental.GraphReader; split[java.lang.String]; java.util.List<java.lang.String>; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; this>
<java.io.BufferedReader; readLine[]; java.lang.String; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; _in>
<org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; org.jgrapht.experimental.GraphReader; readNodeCount[]; int; null; this>
<java.lang.String; equals[java.lang.Object]; boolean; org.jgrapht.experimental.GraphReader; readNodeCount[]; int; null; cols.get(0)>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; readNodeCount[]; int; equals[java.lang.Object]; cols>
<java.lang.Integer; parseInt[java.lang.String]; int; org.jgrapht.experimental.GraphReader; readNodeCount[]; int; null; Integer>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; readNodeCount[]; int; null; cols>
<org.jgrapht.experimental.GraphReader; readNodeCount[]; int; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; this>
<org.jgrapht.VertexFactory; createVertex[]; V; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexFactory>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.lang.Integer; toString[int]; java.lang.String; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; Integer>
<org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; this>
<java.lang.String; equals[java.lang.Object]; boolean; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; cols.get(0)>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; equals[java.lang.Object]; cols>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; addEdge[V, V]; resultMap>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; cols>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; cols>
<org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; this>
<org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<java.lang.Integer,org.jgrapht.graph.DefaultEdge>, org.jgrapht.VertexFactory<java.lang.Integer>, java.util.Map<java.lang.String,java.lang.Integer>]; void; org.jgrapht.experimental.GraphReader; main[java.lang.String[]]; void; null; reader>
<java.io.PrintStream; println[java.lang.Object]; void; org.jgrapht.experimental.GraphReader; main[java.lang.String[]]; void; null; System.out>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; init[]; void; null; this>
<java.awt.Container; setLayout[java.awt.LayoutManager]; void; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; init[]; void; null; this>
<java.awt.Component; setSize[int, int]; void; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; init[]; void; null; this>
<java.awt.Container; add[java.lang.String, java.awt.Component]; java.awt.Component; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; init[]; void; null; this>
<org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; createSamplegraph[]; org.jgrapht.Graph<java.lang.String,org.jgrapht.graph.DefaultEdge>; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; null; this>
<java.awt.Container; add[java.awt.Component]; java.awt.Component; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; null; frame.getContentPane()>
<javax.swing.JFrame; getContentPane[]; java.awt.Container; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; add[java.awt.Component]; frame>
<java.awt.Component; setPreferredSize[java.awt.Dimension]; void; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; null; frame>
<java.awt.Frame; setTitle[java.lang.String]; void; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; null; frame>
<javax.swing.JFrame; setDefaultCloseOperation[int]; void; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; null; frame>
<java.awt.Window; pack[]; void; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; null; frame>
<java.awt.Window; setVisible[boolean]; void; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; null; frame>
<java.lang.Thread; sleep[long]; void; org.jgrapht.experimental.touchgraph.SimpleTouchgraphApplet; main[java.lang.String[]]; void; null; Thread>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; graph>
<java.util.List; size[]; int; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; size[]; int; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes.get(i)>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; toString[]; jgtNodes>
<not found; addNode[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; tgPanel>
<org.jgrapht.Graph; getEdge[V, V]; E; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; graph>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<not found; addEdge[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; tgPanel>
<org.jgrapht.experimental.touchgraph.TouchgraphPanel; preinitialize[]; void; org.jgrapht.experimental.touchgraph.TouchgraphPanel; TouchgraphPanel[org.jgrapht.Graph<V,E>, boolean]; void; null; this>
<org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; org.jgrapht.experimental.touchgraph.TouchgraphPanel; TouchgraphPanel[org.jgrapht.Graph<V,E>, boolean]; void; null; this>
<not found; setBackground[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; preinitialize[]; void; null; this>
<not found; setForeground[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; preinitialize[]; void; null; this>
<not found; setBackColor[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; preinitialize[]; void; null; tgPanel>
<not found; buildPanel[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; this>
<not found; buildLens[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; this>
<not found; setLensSet[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; tgPanel>
<not found; addUIs[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; this>
<not found; randomGraph[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; this>
<org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; converter>
<not found; slowScrollToCenter[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; getHVScroll()>
<not found; getHVScroll[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; slowScrollToCenter[]; this>
<not found; setLocale[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; tgPanel>
<java.io.PrintStream; println[char[]]; void; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; System.err>
<not found; getMessage[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; tge>
<not found; printStackTrace[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; tge>
<not found; setVisible[]; not found; org.jgrapht.experimental.touchgraph.TouchgraphPanel; initialize[]; void; null; this>
<org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[EE[], org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; this>
<java.util.Arrays; asList[EE[]]; java.util.List<EE>; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[EE[], org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; Arrays>
<org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; this>
<java.util.HashMap; values[]; java.util.Collection<java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; map>
<java.util.ArrayList; add[org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; arrayList>
<java.util.ArrayList; size[]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; arrayList>
<java.util.ArrayList; toArray[org.jgrapht.experimental.equivalence.EquivalenceSet[]]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; arrayList>
<java.util.Arrays; sort[org.jgrapht.experimental.equivalence.EquivalenceSet[], java.util.Comparator<? super org.jgrapht.experimental.equivalence.EquivalenceSet>]; void; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; Arrays>
<java.util.Collection; size[]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; elements>
<org.jgrapht.experimental.equivalence.EquivalenceComparator; equivalenceHashcode[, ]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; aEqComparator>
<java.util.HashMap; get[java.lang.Object]; java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; equalityGroupMap>
<java.lang.Integer; valueOf[int]; java.lang.Integer; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; Integer>
<java.util.List; add[org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; list>
<java.util.HashMap; put[java.lang.Integer, java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>]; java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; equalityGroupMap>
<java.lang.Integer; valueOf[int]; java.lang.Integer; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; Integer>
<org.jgrapht.experimental.equivalence.EquivalenceSet; equivalentTo[, ]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; eqGroup>
<org.jgrapht.experimental.equivalence.EquivalenceSet; add[]; void; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; eqGroup>
<java.util.List; add[org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; list>
<org.jgrapht.experimental.equivalence.EquivalenceSet; size[]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator.EqGroupSizeComparator; compare[org.jgrapht.experimental.equivalence.EquivalenceSet, org.jgrapht.experimental.equivalence.EquivalenceSet]; int; null; arg1>
<org.jgrapht.experimental.equivalence.EquivalenceSet; size[]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator.EqGroupSizeComparator; compare[org.jgrapht.experimental.equivalence.EquivalenceSet, org.jgrapht.experimental.equivalence.EquivalenceSet]; int; null; arg2>
<org.jgrapht.experimental.equivalence.EquivalenceSet; hashCode[]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator.EqGroupSizeComparator; compare[org.jgrapht.experimental.equivalence.EquivalenceSet, org.jgrapht.experimental.equivalence.EquivalenceSet]; int; null; arg1>
<org.jgrapht.experimental.equivalence.EquivalenceSet; hashCode[]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator.EqGroupSizeComparator; compare[org.jgrapht.experimental.equivalence.EquivalenceSet, org.jgrapht.experimental.equivalence.EquivalenceSet]; int; null; arg2>
<java.util.Set; add[E]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSet; EquivalenceSet[E, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>, C]; void; null; this.elementsSet>
<java.util.Iterator; next[]; E; org.jgrapht.experimental.equivalence.EquivalenceSet; getRepresentative[]; E; null; elementsSet.iterator()>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.experimental.equivalence.EquivalenceSet; getRepresentative[]; E; next[]; elementsSet>
<java.util.Set; size[]; int; org.jgrapht.experimental.equivalence.EquivalenceSet; size[]; int; null; elementsSet>
<java.util.Set; add[E]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSet; add[E]; void; null; this.elementsSet>
<org.jgrapht.experimental.equivalence.EquivalenceComparator; equivalenceCompare[, , , ]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSet; equivalentTo[E, C]; boolean; null; this.eqComparator>
<org.jgrapht.experimental.equivalence.EquivalenceSet; getRepresentative[]; E; org.jgrapht.experimental.equivalence.EquivalenceSet; equivalentTo[E, C]; boolean; null; this>
<org.jgrapht.experimental.equivalence.EquivalenceSet; getRepresentative[]; E; org.jgrapht.experimental.equivalence.EquivalenceSet; equals[java.lang.Object]; boolean; null; ((EquivalenceSet<E,C>)other)>
<org.jgrapht.experimental.equivalence.EquivalenceSet; getContext[]; C; org.jgrapht.experimental.equivalence.EquivalenceSet; equals[java.lang.Object]; boolean; null; ((EquivalenceSet<E,C>)other)>
<org.jgrapht.experimental.equivalence.EquivalenceComparator; equivalenceCompare[, , , ]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSet; equals[java.lang.Object]; boolean; null; this.eqComparator>
<org.jgrapht.experimental.equivalence.EquivalenceSet; getRepresentative[]; E; org.jgrapht.experimental.equivalence.EquivalenceSet; equals[java.lang.Object]; boolean; null; this>
<org.jgrapht.experimental.equivalence.EquivalenceComparator; equivalenceHashcode[, ]; int; org.jgrapht.experimental.equivalence.EquivalenceSet; hashCode[]; int; null; this.eqComparator>
<org.jgrapht.experimental.equivalence.EquivalenceSet; getRepresentative[]; E; org.jgrapht.experimental.equivalence.EquivalenceSet; hashCode[]; int; null; this>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.experimental.equivalence.EquivalenceSet; toString[]; java.lang.String; null; this.elementsSet>
<java.util.Set; toArray[]; java.lang.Object[]; org.jgrapht.experimental.equivalence.EquivalenceSet; toArray[]; java.lang.Object[]; null; this.elementsSet>
<java.util.List; add[org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; EquivalenceComparatorChainBase[org.jgrapht.experimental.equivalence.EquivalenceComparator<E,C>]; void; null; this.chain>
<java.util.List; add[org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; appendComparator[org.jgrapht.experimental.equivalence.EquivalenceComparator]; void; null; this.chain>
<org.jgrapht.experimental.equivalence.EquivalenceComparator; equivalenceCompare[, , , ]; boolean; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceCompare[E, E, C, C]; boolean; null; currentComparator>
<java.util.List; listIterator[]; java.util.ListIterator<org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>>; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; this.chain>
<java.util.ListIterator; hasNext[]; boolean; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; iter>
<java.util.ListIterator; next[]; org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; iter>
<org.jgrapht.experimental.equivalence.EquivalenceComparator; equivalenceHashcode[, ]; int; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; currentComparator>
<java.lang.StringBuffer; append[int]; java.lang.StringBuffer; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; hashStringBuffer>
<java.util.ListIterator; hasNext[]; boolean; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; iter>
<java.lang.StringBuffer; append[char]; java.lang.StringBuffer; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; hashStringBuffer>
<java.lang.String; hashCode[]; int; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; hashStringBuffer.toString()>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; hashCode[]; hashStringBuffer>
<org.jgrapht.experimental.RandomGraphHelper; addVertices[org.jgrapht.Graph, org.jgrapht.VertexFactory, int]; java.lang.Object[]; org.jgrapht.experimental.PartiteRandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,java.lang.Object[]>]; void; null; RandomGraphHelper>
<java.util.Map; put[java.lang.String, java.lang.Object[]]; java.lang.Object[]; org.jgrapht.experimental.PartiteRandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,java.lang.Object[]>]; void; null; resultMap>
<java.lang.Integer; toString[int]; java.lang.String; org.jgrapht.experimental.PartiteRandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,java.lang.Object[]>]; void; null; Integer>
<org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; org.jgrapht.experimental.PartiteRandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,java.lang.Object[]>]; void; null; RandomGraphHelper>
<java.util.Arrays; asList[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.experimental.PartiteRandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,java.lang.Object[]>]; void; null; Arrays>
<java.util.Arrays; asList[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.experimental.PartiteRandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,java.lang.Object[]>]; void; null; Arrays>
<org.jgrapht.Graph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; org.jgrapht.experimental.GraphSquare; GraphSquare[org.jgrapht.Graph<V,E>, boolean]; void; null; g>
<org.jgrapht.Graphs; addAllVertices[org.jgrapht.Graph<? super V,? super E>, java.util.Collection<? extends V>]; boolean; org.jgrapht.experimental.GraphSquare; GraphSquare[org.jgrapht.Graph<V,E>, boolean]; void; null; Graphs>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphSquare; GraphSquare[org.jgrapht.Graph<V,E>, boolean]; void; null; g>
<org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; org.jgrapht.experimental.GraphSquare; GraphSquare[org.jgrapht.Graph<V,E>, boolean]; void; null; this>
<org.jgrapht.ListenableGraph; addGraphListener[org.jgrapht.event.GraphListener<V,E>]; void; org.jgrapht.experimental.GraphSquare; GraphSquare[org.jgrapht.Graph<V,E>, boolean]; void; null; ((ListenableGraph<V,E>)g)>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; java.lang.Object; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; java.lang.Object; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.Graph; getEdgeSource[E]; V; java.lang.Object; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; g>
<org.jgrapht.Graph; getEdgeTarget[E]; V; java.lang.Object; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; g>
<org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; java.lang.Object; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.Graph; getEdgeTarget[E]; V; java.lang.Object; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; g>
<org.jgrapht.Graph; getEdgeSource[E]; V; java.lang.Object; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; g>
<org.jgrapht.graph.AbstractBaseGraph; edgeSet[]; java.util.Set<E>; java.lang.Object; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; java.lang.Object; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; null; g>
<org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; null; Graphs>
<java.util.List; size[]; int; org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; null; adjVertices>
<java.util.List; get[int]; V; org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; null; adjVertices>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; null; g>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; null; g>
<org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; null; Graphs>
<java.util.List; size[]; int; org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; null; adjVertices>
<org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; null; this>
<java.util.List; get[int]; V; org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; null; adjVertices>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; initialize[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; DirectedAcyclicGraph[java.lang.Class<? extends E>]; void; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; initialize[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; DirectedAcyclicGraph[java.lang.Class<? extends E>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedFactory, org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMappingFactory<V>]; void; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMappingFactory; getTopoOrderMapping[]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMapping<V>; org.jgrapht.experimental.dag.DirectedAcyclicGraph; initialize[]; void; null; topoOrderFactory>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; putVertex[java.lang.Integer, V]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addVertex[V]; boolean; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; putVertex[java.lang.Integer, V]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addVertex[V, boolean]; boolean; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V]; E; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V]; E; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$VisitedFactory; getInstance[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V]; E; null; visitedFactory>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V]; E; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V]; E; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V]; E; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V]; E; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractBaseGraph; containsEdge[E]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V, E]; boolean; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V, E]; boolean; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V, E]; boolean; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$VisitedFactory; getInstance[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V, E]; boolean; null; visitedFactory>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V, E]; boolean; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V, E]; boolean; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V, E]; boolean; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; addDagEdge[V, V, E]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; removeVertex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; removeVertex[V]; boolean; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getVertex[java.lang.Integer]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph; removeVertex[V]; boolean; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getVertex[java.lang.Integer]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph; removeVertex[V]; boolean; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; removeAllVertices[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; removeAllVertices[java.util.Collection<? extends V>]; boolean; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Visited; setVisited[int]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; visited>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; df>
<org.jgrapht.graph.AbstractBaseGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; topoOrderMap>
<java.lang.Integer; intValue[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; nextVertexTopoIndex>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Visited; clearVisited[int]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Region; isIn[int]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; affectedRegion>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Visited; getVisited[int]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Visited; setVisited[int]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; visited>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; db>
<org.jgrapht.graph.AbstractBaseGraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Region; isIn[int]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; affectedRegion>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Visited; getVisited[int]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; this>
<java.util.Collections; sort[java.util.List<V>, java.util.Comparator<? super V>]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; Collections>
<java.util.Collections; sort[java.util.List<V>, java.util.Comparator<? super V>]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; Collections>
<java.util.Set; size[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; df>
<java.util.Set; size[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; db>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; topoOrderMap>
<java.util.Set; add[java.lang.Integer]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; availableTopoIndices>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Visited; clearVisited[int]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; topoOrderMap>
<java.util.Set; add[java.lang.Integer]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; availableTopoIndices>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Visited; clearVisited[int]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; putVertex[java.lang.Integer, V]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; topoOrderMap>
<java.lang.Integer; compareTo[java.lang.Integer]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoComparator; compare[V, V]; int; null; topoOrderMap.getTopologicalIndex(o1)>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoComparator; compare[V, V]; int; compareTo[java.lang.Integer]; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getTopologicalIndex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoComparator; compare[V, V]; int; null; topoOrderMap>
<java.util.Map; put[java.lang.Integer, V]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; putVertex[java.lang.Integer, V]; void; null; topoToVertex>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; putVertex[java.lang.Integer, V]; void; null; vertexToTopo>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; getVertex[java.lang.Integer]; V; null; topoToVertex>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; getTopologicalIndex[V]; java.lang.Integer; null; vertexToTopo>
<java.util.Map; remove[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; removeVertex[V]; java.lang.Integer; null; vertexToTopo>
<java.util.Map; remove[java.lang.Object]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; removeVertex[V]; java.lang.Integer; null; topoToVertex>
<java.util.Map; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; removeAllVertices[]; void; null; vertexToTopo>
<java.util.Map; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; removeAllVertices[]; void; null; topoToVertex>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoVertexMap; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; this>
<java.util.List; size[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; topoToVertex>
<java.util.List; add[V]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; topoToVertex>
<java.util.List; set[int, V]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; topoToVertex>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; vertexToTopo>
<java.util.List; get[int]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; getVertex[java.lang.Integer]; V; null; topoToVertex>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoVertexMap; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; getVertex[java.lang.Integer]; V; null; this>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; getTopologicalIndex[V]; java.lang.Integer; null; vertexToTopo>
<java.util.Map; remove[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeVertex[V]; java.lang.Integer; null; vertexToTopo>
<java.util.List; set[int, V]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeVertex[V]; java.lang.Integer; null; topoToVertex>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoVertexMap; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeVertex[V]; java.lang.Integer; null; this>
<java.util.Map; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeAllVertices[]; void; null; vertexToTopo>
<java.util.List; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeAllVertices[]; void; null; topoToVertex>
<java.util.BitSet; set[int, boolean]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedBitSetImpl; setVisited[int]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$VisitedBitSetImpl; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedBitSetImpl; setVisited[int]; void; null; this>
<java.util.BitSet; get[int]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedBitSetImpl; getVisited[int]; boolean; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$VisitedBitSetImpl; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedBitSetImpl; getVisited[int]; boolean; null; this>
<java.util.BitSet; clear[int]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedBitSetImpl; clearVisited[int]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$VisitedBitSetImpl; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedBitSetImpl; clearVisited[int]; void; null; this>
<java.util.List; size[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; getInstance[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited; null; visited>
<java.util.List; add[java.lang.Boolean]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; getInstance[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited; null; visited>
<java.util.List; set[int, java.lang.Boolean]; java.lang.Boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; setVisited[int]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$VisitedArrayListImpl; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; setVisited[int]; void; null; this>
<java.util.List; get[int]; java.lang.Boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; getVisited[int]; boolean; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$VisitedArrayListImpl; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; getVisited[int]; boolean; null; this>
<java.util.List; set[int, java.lang.Boolean]; java.lang.Boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; clearVisited[int]; void; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$VisitedArrayListImpl; translateIndex[int]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; clearVisited[int]; void; null; this>
<java.util.Set; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedHashSetImpl; getInstance[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited; null; visited>
<java.util.Set; add[java.lang.Integer]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedHashSetImpl; setVisited[int]; void; null; visited>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedHashSetImpl; getVisited[int]; boolean; null; visited>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$Region; getSize[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayImpl; VisitedArrayImpl[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; region>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoIterator; getNextIndex[]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoIterator; hasNext[]; boolean; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoIterator; getNextIndex[]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoIterator; next[]; V; null; this>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getVertex[java.lang.Integer]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoIterator; next[]; V; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getVertex[java.lang.Integer]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoIterator; remove[]; void; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; removeVertex[V]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoIterator; remove[]; void; null; topoOrderMap>
<org.jgrapht.experimental.dag.DirectedAcyclicGraph$TopoOrderMapping; getVertex[java.lang.Integer]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoIterator; getNextIndex[]; java.lang.Integer; null; topoOrderMap>
<org.jgrapht.experimental.RandomGraphHelper; addVertices[org.jgrapht.Graph, org.jgrapht.VertexFactory, int]; java.lang.Object[]; org.jgrapht.experimental.UniformRandomGraphGenerator; generateGraph[org.jgrapht.Graph, org.jgrapht.VertexFactory, java.util.Map]; void; null; RandomGraphHelper>
<org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; org.jgrapht.experimental.UniformRandomGraphGenerator; generateGraph[org.jgrapht.Graph, org.jgrapht.VertexFactory, java.util.Map]; void; null; RandomGraphHelper>
<java.util.Arrays; asList[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.experimental.UniformRandomGraphGenerator; generateGraph[org.jgrapht.Graph, org.jgrapht.VertexFactory, java.util.Map]; void; null; Arrays>
<java.util.Arrays; asList[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.experimental.UniformRandomGraphGenerator; generateGraph[org.jgrapht.Graph, org.jgrapht.VertexFactory, java.util.Map]; void; null; Arrays>
<java.util.Set; size[]; int; org.jgrapht.experimental.permutation.CollectionPermutationIter; CollectionPermutationIter[java.util.Set<E>]; void; null; objectsSet>
<java.util.List; size[]; int; org.jgrapht.experimental.permutation.CollectionPermutationIter; CollectionPermutationIter[java.util.List<E>]; void; null; objectsArray>
<org.jgrapht.experimental.permutation.ArrayPermutationsIter; hasNextPermutaions[]; boolean; org.jgrapht.experimental.permutation.CollectionPermutationIter; hasNext[]; boolean; null; this.permOrder>
<org.jgrapht.experimental.permutation.ArrayPermutationsIter; hasNextPermutaions[]; boolean; org.jgrapht.experimental.permutation.CollectionPermutationIter; getNextArray[]; java.util.List<E>; null; this.permOrder>
<org.jgrapht.experimental.permutation.ArrayPermutationsIter; nextPermutation[]; int[]; org.jgrapht.experimental.permutation.CollectionPermutationIter; getNextArray[]; java.util.List<E>; null; this.permOrder>
<org.jgrapht.experimental.permutation.CollectionPermutationIter; applyPermutation[]; java.util.List<E>; org.jgrapht.experimental.permutation.CollectionPermutationIter; getNextArray[]; java.util.List<E>; null; this>
<java.util.ArrayList; size[]; int; org.jgrapht.experimental.permutation.CollectionPermutationIter; applyPermutation[]; java.util.List<E>; null; output>
<java.util.ArrayList; set[int, E]; E; org.jgrapht.experimental.permutation.CollectionPermutationIter; applyPermutation[]; java.util.List<E>; null; output>
<java.util.List; get[int]; E; org.jgrapht.experimental.permutation.CollectionPermutationIter; applyPermutation[]; java.util.List<E>; null; this.sourceArray>
<org.jgrapht.experimental.permutation.CollectionPermutationIter; getNextArray[]; java.util.List<E>; org.jgrapht.experimental.permutation.CollectionPermutationIter; getNextSet[]; java.util.Set<E>; null; this>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; sb>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; sb>
<java.util.Arrays; toString[int[]]; java.lang.String; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; Arrays>
<org.jgrapht.experimental.permutation.CollectionPermutationIter; getCurrentPermutationArray[]; int[]; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; this>
<org.jgrapht.experimental.permutation.CollectionPermutationIter; applyPermutation[]; java.util.List<E>; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; this>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; sb>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; sb>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; this.sourceArray>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; sb>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; sb>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; permutationResult>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.experimental.permutation.CollectionPermutationIter; toString[]; java.lang.String; null; sb>
<org.jgrapht.experimental.permutation.CompoundPermutationIter; init[int[]]; void; org.jgrapht.experimental.permutation.CompoundPermutationIter; CompoundPermutationIter[int[]]; void; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; getNext[]; int[]; org.jgrapht.experimental.permutation.CompoundPermutationIter; init[int[]]; void; null; this.permArray[eqGroup]>
<org.jgrapht.util.MathUtil; factorial[int]; long; org.jgrapht.experimental.permutation.CompoundPermutationIter; init[int[]]; void; null; MathUtil>
<org.jgrapht.experimental.permutation.CompoundPermutationIter; getNext[]; int[]; org.jgrapht.experimental.permutation.CompoundPermutationIter; next[]; java.lang.Object; null; this>
<org.jgrapht.experimental.permutation.CompoundPermutationIter; getPermAsArray[]; int[]; org.jgrapht.experimental.permutation.CompoundPermutationIter; getNext[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; hasNext[]; boolean; org.jgrapht.experimental.permutation.CompoundPermutationIter; getNext[]; int[]; null; currGroup>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; getNext[]; int[]; org.jgrapht.experimental.permutation.CompoundPermutationIter; getNext[]; int[]; null; currGroup>
<org.jgrapht.experimental.permutation.CompoundPermutationIter; restartPermutationGroup[int]; void; org.jgrapht.experimental.permutation.CompoundPermutationIter; getNext[]; int[]; null; this>
<org.jgrapht.experimental.permutation.CompoundPermutationIter; getPermAsArray[]; int[]; org.jgrapht.experimental.permutation.CompoundPermutationIter; getNext[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; getCurrent[]; int[]; org.jgrapht.experimental.permutation.CompoundPermutationIter; getPermAsArray[]; int[]; null; this.permArray[groupIndex]>
<java.lang.System; arraycopy[java.lang.Object, int, java.lang.Object, int, int]; void; org.jgrapht.experimental.permutation.CompoundPermutationIter; getPermAsArray[]; int[]; null; System>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; getCurrent[]; int[]; org.jgrapht.experimental.permutation.CompoundPermutationIter; restartPermutationGroup[int]; void; null; this.permArray[groupIndex]>
<java.util.Arrays; sort[int[]]; void; org.jgrapht.experimental.permutation.CompoundPermutationIter; restartPermutationGroup[int]; void; null; Arrays>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; getNext[]; int[]; org.jgrapht.experimental.permutation.CompoundPermutationIter; restartPermutationGroup[int]; void; null; this.permArray[groupIndex]>
<org.jgrapht.experimental.permutation.CompoundPermutationIter; next[]; java.lang.Object; org.jgrapht.experimental.permutation.CompoundPermutationIter; nextPermutation[]; int[]; null; this>
<org.jgrapht.experimental.permutation.CompoundPermutationIter; hasNext[]; boolean; org.jgrapht.experimental.permutation.CompoundPermutationIter; hasNextPermutaions[]; boolean; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; init[int[]]; void; org.jgrapht.experimental.permutation.IntegerPermutationIter; IntegerPermutationIter[int]; void; null; this>
<java.lang.System; arraycopy[java.lang.Object, int, java.lang.Object, int, int]; void; org.jgrapht.experimental.permutation.IntegerPermutationIter; IntegerPermutationIter[int[]]; void; null; System>
<java.util.Arrays; sort[int[]]; void; org.jgrapht.experimental.permutation.IntegerPermutationIter; IntegerPermutationIter[int[]]; void; null; Arrays>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; init[int[]]; void; org.jgrapht.experimental.permutation.IntegerPermutationIter; IntegerPermutationIter[int[]]; void; null; this>
<java.lang.System; arraycopy[java.lang.Object, int, java.lang.Object, int, int]; void; org.jgrapht.experimental.permutation.IntegerPermutationIter; arrayClone[int[]]; int[]; null; System>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; swap[int, int]; void; org.jgrapht.experimental.permutation.IntegerPermutationIter; getNextStartingWith2[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; swap[int, int]; void; org.jgrapht.experimental.permutation.IntegerPermutationIter; getNextStartingWith2[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; getNextStartingWith2[]; int[]; org.jgrapht.experimental.permutation.IntegerPermutationIter; hasNext[]; boolean; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; getNext[]; int[]; org.jgrapht.experimental.permutation.IntegerPermutationIter; next[]; java.lang.Object; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; hasNext[]; boolean; org.jgrapht.experimental.permutation.IntegerPermutationIter; getNext[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; getNextStartingWith2[]; int[]; org.jgrapht.experimental.permutation.IntegerPermutationIter; getNext[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; arrayClone[int[]]; int[]; org.jgrapht.experimental.permutation.IntegerPermutationIter; getNext[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; arrayClone[int[]]; int[]; org.jgrapht.experimental.permutation.IntegerPermutationIter; getNext[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; arrayClone[int[]]; int[]; org.jgrapht.experimental.permutation.IntegerPermutationIter; getCurrent[]; int[]; null; this>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.IntegerPermutationIter; toString[int[]]; java.lang.String; null; stBuffer.append(array[i])>
<java.lang.StringBuffer; append[int]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.IntegerPermutationIter; toString[int[]]; java.lang.String; append[java.lang.String]; stBuffer>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.IntegerPermutationIter; toString[int[]]; java.lang.String; null; stBuffer.append(array[array.length - 1])>
<java.lang.StringBuffer; append[int]; java.lang.StringBuffer; org.jgrapht.experimental.permutation.IntegerPermutationIter; toString[int[]]; java.lang.String; append[java.lang.String]; stBuffer>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.experimental.permutation.IntegerPermutationIter; toString[int[]]; java.lang.String; null; stBuffer>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; next[]; java.lang.Object; org.jgrapht.experimental.permutation.IntegerPermutationIter; nextPermutation[]; int[]; null; this>
<org.jgrapht.experimental.permutation.IntegerPermutationIter; hasNext[]; boolean; org.jgrapht.experimental.permutation.IntegerPermutationIter; hasNextPermutaions[]; boolean; null; this>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isEmpty[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.GraphTests; isEmpty[org.jgrapht.Graph<V,E>]; boolean; isEmpty[]; g>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isComplete[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphTests; isComplete[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isComplete[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.GraphTests; isComplete[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<java.util.Iterator; next[]; V; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet().iterator()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; next[]; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; iterator[]; g>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; known>
<java.util.AbstractCollection; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.LinkedList; removeFirst[]; V; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; Graphs.neighborListOf(g,v)>
<org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; iterator[]; Graphs>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; it>
<java.util.Iterator; next[]; V; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; it>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; known>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; known>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; known>
<org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; null; this>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; size[]; g>
<org.jgrapht.experimental.GraphTests; isEmpty[org.jgrapht.Graph<V,E>]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; this>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g>
<java.util.Iterator; next[]; V; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; unknown.iterator()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; next[]; unknown>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; unknown>
<java.util.AbstractCollection; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Iterator; next[]; V; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; unknown.iterator()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; next[]; unknown>
<java.util.LinkedList; removeFirst[]; V; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; unknown>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; Graphs.neighborListOf(g,v)>
<org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; iterator[]; Graphs>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; it>
<java.util.Iterator; next[]; V; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; it>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; unknown>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; odd>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; odd>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; odd>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; odd>
<org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; getInOutDegrees[org.jgrapht.Graph<V,E>, V]; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator<V,E>.InOutDegrees; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceCompare[V, V, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>]; boolean; null; this>
<org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; getInOutDegrees[org.jgrapht.Graph<V,E>, V]; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator<V,E>.InOutDegrees; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceCompare[V, V, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>]; boolean; null; this>
<org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator$InOutDegrees; equals[java.lang.Object]; boolean; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceCompare[V, V, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>]; boolean; null; inOut1>
<org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; getInOutDegrees[org.jgrapht.Graph<V,E>, V]; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator<V,E>.InOutDegrees; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceHashcode[V, org.jgrapht.Graph<V,E>]; int; null; this>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceHashcode[V, org.jgrapht.Graph<V,E>]; int; null; sb>
<java.lang.String; valueOf[int]; java.lang.String; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceHashcode[V, org.jgrapht.Graph<V,E>]; int; null; String>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceHashcode[V, org.jgrapht.Graph<V,E>]; int; null; sb>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceHashcode[V, org.jgrapht.Graph<V,E>]; int; null; sb>
<java.lang.String; valueOf[int]; java.lang.String; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceHashcode[V, org.jgrapht.Graph<V,E>]; int; null; String>
<java.lang.String; hashCode[]; int; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceHashcode[V, org.jgrapht.Graph<V,E>]; int; null; sb.toString()>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; equivalenceHashcode[V, org.jgrapht.Graph<V,E>]; int; hashCode[]; sb>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; getInOutDegrees[org.jgrapht.Graph<V,E>, V]; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator<V,E>.InOutDegrees; null; undirectedGraph>
<org.jgrapht.DirectedGraph; inDegreeOf[V]; int; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; getInOutDegrees[org.jgrapht.Graph<V,E>, V]; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator<V,E>.InOutDegrees; null; directedGraph>
<org.jgrapht.DirectedGraph; outDegreeOf[V]; int; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator; getInOutDegrees[org.jgrapht.Graph<V,E>, V]; org.jgrapht.experimental.isomorphism.VertexDegreeEquivalenceComparator<V,E>.InOutDegrees; null; directedGraph>
<org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; checkGraphsType[org.jgrapht.Graph, org.jgrapht.Graph]; int; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createIsomorphismInspector[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; this>
<org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createAppropriateConcreteInspector[int, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createIsomorphismInspector[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; this>
<org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createIsomorphismInspector[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createIsomorphismInspector[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; this>
<org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createAppropriateConcreteInspector[int, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createIsomorphismInspectorByType[int, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; this>
<org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createAppropriateConcreteInspector[int, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createIsomorphismInspectorByType[int, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; this>
<org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; assertUnsupportedGraphTypes[org.jgrapht.Graph]; void; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createAppropriateConcreteInspector[int, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; this>
<org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; assertUnsupportedGraphTypes[org.jgrapht.Graph]; void; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createAppropriateConcreteInspector[int, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; this>
<org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createTopologicalExhaustiveInspector[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createAppropriateConcreteInspector[int, org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; this>
<org.jgrapht.experimental.equivalence.EquivalenceComparatorChain; appendComparator[org.jgrapht.experimental.equivalence.EquivalenceComparator]; void; org.jgrapht.experimental.isomorphism.AdaptiveIsomorphismInspectorFactory; createTopologicalExhaustiveInspector[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; org.jgrapht.experimental.isomorphism.GraphIsomorphismInspector; null; vertexChainedChecker>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.isomorphism.GraphOrdering; GraphOrdering[org.jgrapht.Graph<V,E>]; void; null; regularGraph>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.isomorphism.GraphOrdering; GraphOrdering[org.jgrapht.Graph<V,E>]; void; null; regularGraph>
<org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; org.jgrapht.experimental.isomorphism.GraphOrdering; GraphOrdering[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; this>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; vertexSet>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; mapVertexToOrder>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; edgeSet>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; g>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; mapVertexToOrder>
<java.lang.Integer; intValue[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; sourceOrder>
<java.lang.Integer; intValue[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; (mapVertexToOrder.get(g.getEdgeTarget(edge)))>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; intValue[]; mapVertexToOrder>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; g>
<java.util.Set; add[org.jgrapht.experimental.isomorphism.GraphOrdering<V,E>.LabelsEdge]; boolean; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; this.labelsEdgesSet>
<java.util.Set; add[org.jgrapht.experimental.isomorphism.GraphOrdering<V,E>.LabelsEdge]; boolean; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; this.labelsEdgesSet>
<java.util.Set; equals[java.lang.Object]; boolean; org.jgrapht.experimental.isomorphism.GraphOrdering; equalsByEdgeOrder[org.jgrapht.experimental.isomorphism.GraphOrdering]; boolean; null; this.getLabelsEdgesSet()>
<org.jgrapht.experimental.isomorphism.GraphOrdering; getLabelsEdgesSet[]; java.util.Set<org.jgrapht.experimental.isomorphism.GraphOrdering<V,E>.LabelsEdge>; org.jgrapht.experimental.isomorphism.GraphOrdering; equalsByEdgeOrder[org.jgrapht.experimental.isomorphism.GraphOrdering]; boolean; equals[java.lang.Object]; this>
<org.jgrapht.experimental.isomorphism.GraphOrdering; getLabelsEdgesSet[]; java.util.Set; org.jgrapht.experimental.isomorphism.GraphOrdering; equalsByEdgeOrder[org.jgrapht.experimental.isomorphism.GraphOrdering]; boolean; null; otherGraph>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; sb>
<java.util.Map; size[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; this.mapVertexToOrder>
<java.util.Map; keySet[]; java.util.Set<V>; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; this.mapVertexToOrder>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; this.mapVertexToOrder>
<java.lang.Integer; intValue[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; index>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; sb>
<java.util.Arrays; toString[java.lang.Object[]]; java.lang.String; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; Arrays>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; sb.append("labelsOrder=")>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; append[java.lang.String]; sb>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; this.labelsEdgesSet>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; sb>
<java.lang.String; hashCode[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering.LabelsEdge; LabelsEdge[int, int]; void; null; new String(this.source + "" + this.target)>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet1>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet2>
<org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<V>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.Graph<V,E>]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; EquivalenceSetCreator>
<org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<V>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<V,E>>, org.jgrapht.Graph<V,E>]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; EquivalenceSetCreator>
<org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; reorderTargetArrayToMatchSourceOrder[org.jgrapht.experimental.equivalence.EquivalenceSet[], org.jgrapht.experimental.equivalence.EquivalenceSet[]]; boolean; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; this>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet1>
<org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; fillElementsflatArray[org.jgrapht.experimental.equivalence.EquivalenceSet[], java.lang.Object[]]; void; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; this>
<java.util.Set; clear[]; void; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet1>
<java.util.Set; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet1>
<java.util.Arrays; asList[V[]]; java.util.List<V>; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; Arrays>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet2>
<org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; fillElementsflatArray[org.jgrapht.experimental.equivalence.EquivalenceSet[], java.lang.Object[]]; void; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; this>
<org.jgrapht.experimental.equivalence.EquivalenceSet; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; eqGroupArray2[eqGroupCounter]>
<org.jgrapht.experimental.permutation.PermutationFactory; createByGroups[int[]]; org.jgrapht.experimental.permutation.ArrayPermutationsIter; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; PermutationFactory>
<java.util.Arrays; asList[V[]]; java.util.List<V>; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; Arrays>
<org.jgrapht.experimental.equivalence.EquivalenceSet; equals[java.lang.Object]; boolean; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; reorderTargetArrayToMatchSourceOrder[org.jgrapht.experimental.equivalence.EquivalenceSet[], org.jgrapht.experimental.equivalence.EquivalenceSet[]]; boolean; null; sourceEqGroup>
<org.jgrapht.experimental.equivalence.EquivalenceSet; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; reorderTargetArrayToMatchSourceOrder[org.jgrapht.experimental.equivalence.EquivalenceSet[], org.jgrapht.experimental.equivalence.EquivalenceSet[]]; boolean; null; sourceEqGroup>
<org.jgrapht.experimental.equivalence.EquivalenceSet; hashCode[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; reorderTargetArrayToMatchSourceOrder[org.jgrapht.experimental.equivalence.EquivalenceSet[], org.jgrapht.experimental.equivalence.EquivalenceSet[]]; boolean; null; sourceEqGroup>
<org.jgrapht.experimental.equivalence.EquivalenceSet; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; reorderTargetArrayToMatchSourceOrder[org.jgrapht.experimental.equivalence.EquivalenceSet[], org.jgrapht.experimental.equivalence.EquivalenceSet[]]; boolean; null; targetEqGroup>
<org.jgrapht.experimental.equivalence.EquivalenceSet; hashCode[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; reorderTargetArrayToMatchSourceOrder[org.jgrapht.experimental.equivalence.EquivalenceSet[], org.jgrapht.experimental.equivalence.EquivalenceSet[]]; boolean; null; targetEqGroup>
<org.jgrapht.experimental.equivalence.EquivalenceSet; equals[java.lang.Object]; boolean; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; reorderTargetArrayToMatchSourceOrder[org.jgrapht.experimental.equivalence.EquivalenceSet[], org.jgrapht.experimental.equivalence.EquivalenceSet[]]; boolean; null; targetEqGroup>
<org.jgrapht.experimental.equivalence.EquivalenceSet; toArray[]; java.lang.Object[]; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; fillElementsflatArray[org.jgrapht.experimental.equivalence.EquivalenceSet[], java.lang.Object[]]; void; null; eqGroupArray[eqGroupCounter]>
<java.lang.System; arraycopy[java.lang.Object, int, java.lang.Object, int, int]; void; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; fillElementsflatArray[org.jgrapht.experimental.equivalence.EquivalenceSet[], java.lang.Object[]]; void; null; System>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.IsomorphismRelation; toString[]; java.lang.String; null; sb.append("vertexList1: ")>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.IsomorphismRelation; toString[]; java.lang.String; append[java.lang.String]; sb>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.experimental.isomorphism.IsomorphismRelation; toString[]; java.lang.String; null; this.vertexList1>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.IsomorphismRelation; toString[]; java.lang.String; null; sb.append("\tvertexList2: ")>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.experimental.isomorphism.IsomorphismRelation; toString[]; java.lang.String; append[java.lang.String]; sb>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.experimental.isomorphism.IsomorphismRelation; toString[]; java.lang.String; null; this.vertexList2>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.experimental.isomorphism.IsomorphismRelation; toString[]; java.lang.String; null; sb>
<org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; org.jgrapht.experimental.isomorphism.IsomorphismRelation; getVertexCorrespondence[V, boolean]; V; null; this>
<org.jgrapht.GraphMapping; getVertexCorrespondence[V, boolean]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; getVertexCorrespondence[V, boolean]; V; null; graphMapping>
<org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; org.jgrapht.experimental.isomorphism.IsomorphismRelation; getEdgeCorrespondence[E, boolean]; E; null; this>
<org.jgrapht.GraphMapping; getEdgeCorrespondence[E, boolean]; E; org.jgrapht.experimental.isomorphism.IsomorphismRelation; getEdgeCorrespondence[E, boolean]; E; null; graphMapping>
<java.util.List; size[]; int; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; vertexList1>
<java.util.List; get[int]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; this.vertexList1>
<java.util.List; get[int]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; this.vertexList2>
<java.util.Map; put[V, V]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; g1ToG2>
<java.util.Map; put[V, V]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; g2ToG1>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; vertexSet1>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; vertexSet2>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; vertexSet2>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; vertexSet1>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; iter1>
<java.util.Iterator; next[]; V; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; iter1>
<java.util.Iterator; next[]; V; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; iter2>
<org.jgrapht.experimental.equivalence.EquivalenceComparator; equivalenceCompare[, , , ]; boolean; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; this.vertexComparator>
<org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; init[]; void; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; AbstractExhaustiveIsomorphismInspector[org.jgrapht.Graph<V,E>, org.jgrapht.Graph<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super V,? super org.jgrapht.Graph<? super V,? super E>>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<? super V,? super E>>]; void; null; this>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; init[]; void; null; this.graph1>
<org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; init[]; void; null; this>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; init[]; void; null; this.graph2>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; init[]; void; null; this.graph1>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; init[]; void; null; this.graph2>
<org.jgrapht.experimental.permutation.CollectionPermutationIter; hasNext[]; boolean; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; findNextIsomorphicGraph[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>; null; this.vertexPermuteIter>
<org.jgrapht.experimental.permutation.CollectionPermutationIter; getNextSet[]; java.util.Set<V>; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; findNextIsomorphicGraph[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>; null; this.vertexPermuteIter>
<org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; findNextIsomorphicGraph[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>; null; this>
<org.jgrapht.experimental.isomorphism.GraphOrdering; equalsByEdgeOrder[org.jgrapht.experimental.isomorphism.GraphOrdering]; boolean; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; findNextIsomorphicGraph[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>; null; this.lableGraph1>
<org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; areAllEdgesEquivalent[org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; boolean; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; findNextIsomorphicGraph[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>; null; this>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; areAllEdgesEquivalent[org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; boolean; null; this.graph1>
<org.jgrapht.experimental.isomorphism.IsomorphismRelation; getEdgeCorrespondence[E, boolean]; E; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; areAllEdgesEquivalent[org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; boolean; null; resultRelation>
<org.jgrapht.experimental.equivalence.EquivalenceComparator; equivalenceCompare[, , , ]; boolean; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; areAllEdgesEquivalent[org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super org.jgrapht.Graph<V,E>>]; boolean; null; edgeComparator>
<org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; next[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; nextIsoRelation[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation; null; this>
<org.jgrapht.util.PrefetchIterator; isEnumerationStartedEmpty[]; boolean; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; isIsomorphic[]; boolean; null; this.nextSupplier>
<org.jgrapht.util.PrefetchIterator; hasMoreElements[]; boolean; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; hasNext[]; boolean; null; this.nextSupplier>
<org.jgrapht.util.PrefetchIterator; nextElement[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; next[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation; null; this.nextSupplier>
<org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector; findNextIsomorphicGraph[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation<V,E>; org.jgrapht.experimental.isomorphism.AbstractExhaustiveIsomorphismInspector.NextFunctor; nextElement[]; org.jgrapht.experimental.isomorphism.IsomorphismRelation; null; this>
<java.util.BitSet; clear[]; void; org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; null; usedColors>
<java.util.BitSet; set[int]; void; org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; null; usedColors>
<java.util.BitSet; get[int]; boolean; org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; null; usedColors>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[degree[i]]>
<java.util.List; size[]; int; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[i]>
<java.util.List; size[]; int; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[i]>
<java.util.List; get[int]; java.lang.Object; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[i]>
<java.util.List; remove[int]; java.lang.Object; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[i]>
<java.util.List; remove[java.lang.Object]; boolean; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[degree[nb]]>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[degree[nb]]>
<java.util.Collections; reverse[java.util.List<?>]; void; org.jgrapht.experimental.alg.color.GreedyColoring; largestSaturationFirstOrder[]; int[]; null; Collections>
<java.util.Arrays; asList[int[][]]; java.util.List<int[]>; org.jgrapht.experimental.alg.color.GreedyColoring; largestSaturationFirstOrder[]; int[]; null; Arrays>
<java.lang.Math; min[int, int]; int; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; Math>
<java.lang.Math; min[int, int]; int; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; Math>
<org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; largestSaturationFirstOrder[]; int[]; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; color[int[]]; int; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<org.jgrapht.experimental.alg.color.GreedyColoring; largestSaturationFirstOrder[]; int[]; org.jgrapht.experimental.alg.color.GreedyColoring; getUpperBound[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<java.util.BitSet; set[int, int]; void; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; recursiveColor[int]; void; null; _allowedColors[pos]>
<java.util.BitSet; clear[int]; void; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; recursiveColor[int]; void; null; _allowedColors[pos]>
<java.util.BitSet; get[int]; boolean; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; recursiveColor[int]; void; null; _allowedColors[pos]>
<org.jgrapht.experimental.alg.color.BrownBacktrackColoring; recursiveColor[int]; void; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; recursiveColor[int]; void; null; this>
<org.jgrapht.experimental.alg.color.BrownBacktrackColoring; recursiveColor[int]; void; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; recursiveColor[int]; void; null; this>
<org.jgrapht.experimental.alg.color.BrownBacktrackColoring; recursiveColor[int]; void; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; getResult[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; this>
<java.util.List; size[]; int; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; getResult[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; _vertices>
<java.util.Map; put[V, java.lang.Object]; java.lang.Object; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; getResult[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; additionalData>
<java.util.List; get[int]; V; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; getResult[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; _vertices>
<java.util.Set; size[]; int; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; size[]; g>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; g>
<java.util.List; add[V]; boolean; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; _vertices>
<java.util.Set; size[]; int; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; g.edgesOf(vertex)>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; size[]; g>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; _vertexToPos>
<java.util.List; get[int]; V; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; _vertices>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; g>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; _vertexToPos>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; Graphs>
<java.util.List; size[]; int; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; sourceVertices>
<java.util.List; size[]; int; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; destVertices>
<org.jgrapht.Graph; addEdge[java.lang.Object, java.lang.Object]; java.lang.Object; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; target>
<java.util.List; get[int]; java.lang.Object; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; addEdge[java.lang.Object, java.lang.Object]; sourceVertices>
<java.util.Random; nextInt[int]; int; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; randSingleton>
<java.util.List; get[int]; java.lang.Object; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; destVertices>
<java.util.Random; nextInt[int]; int; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; randSingleton>
<org.jgrapht.VertexFactory; createVertex[]; java.lang.Object; org.jgrapht.experimental.RandomGraphHelper; addVertices[org.jgrapht.Graph, org.jgrapht.VertexFactory, int]; java.lang.Object[]; null; vertexFactory>
<org.jgrapht.Graph; addVertex[java.lang.Object]; boolean; org.jgrapht.experimental.RandomGraphHelper; addVertices[org.jgrapht.Graph, org.jgrapht.VertexFactory, int]; java.lang.Object[]; null; target>
<java.lang.Math; log[double]; double; org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<T>]; T; null; Math>
<java.lang.Math; sqrt[double]; double; org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<T>]; T; null; Math>
<org.jgrapht.util.FibonacciHeap; cut[org.jgrapht.util.FibonacciHeapNode<T>, org.jgrapht.util.FibonacciHeapNode<T>]; void; org.jgrapht.util.FibonacciHeap; decreaseKey[org.jgrapht.util.FibonacciHeapNode<T>, double]; void; null; this>
<org.jgrapht.util.FibonacciHeap; cascadingCut[org.jgrapht.util.FibonacciHeapNode<T>]; void; org.jgrapht.util.FibonacciHeap; decreaseKey[org.jgrapht.util.FibonacciHeapNode<T>, double]; void; null; this>
<org.jgrapht.util.FibonacciHeap; decreaseKey[org.jgrapht.util.FibonacciHeapNode<T>, double]; void; org.jgrapht.util.FibonacciHeap; delete[org.jgrapht.util.FibonacciHeapNode<T>]; void; null; this>
<org.jgrapht.util.FibonacciHeap; removeMin[]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; delete[org.jgrapht.util.FibonacciHeapNode<T>]; void; null; this>
<org.jgrapht.util.FibonacciHeap; consolidate[]; void; org.jgrapht.util.FibonacciHeap; removeMin[]; org.jgrapht.util.FibonacciHeapNode<T>; null; this>
<java.util.Stack; push[org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; buf>
<java.util.Stack; empty[]; boolean; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.util.Stack; pop[]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.lang.StringBuffer; append[java.lang.Object]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; buf>
<java.util.Stack; push[org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.lang.StringBuffer; append[java.lang.Object]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; buf>
<java.util.Stack; push[org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.lang.StringBuffer; append[char]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; buf>
<org.jgrapht.util.FibonacciHeap; cut[org.jgrapht.util.FibonacciHeapNode<T>, org.jgrapht.util.FibonacciHeapNode<T>]; void; org.jgrapht.util.FibonacciHeap; cascadingCut[org.jgrapht.util.FibonacciHeapNode<T>]; void; null; this>
<org.jgrapht.util.FibonacciHeap; cascadingCut[org.jgrapht.util.FibonacciHeapNode<T>]; void; org.jgrapht.util.FibonacciHeap; cascadingCut[org.jgrapht.util.FibonacciHeapNode<T>]; void; null; this>
<java.lang.Math; floor[double]; double; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; Math>
<java.lang.Math; log[double]; double; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; Math>
<java.util.List; add[org.jgrapht.util.FibonacciHeapNode<T>]; boolean; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<java.util.List; get[int]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<org.jgrapht.util.FibonacciHeap; link[org.jgrapht.util.FibonacciHeapNode<T>, org.jgrapht.util.FibonacciHeapNode<T>]; void; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; this>
<java.util.List; set[int, org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<java.util.List; set[int, org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<java.util.List; get[int]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<org.jgrapht.util.ModifiableInteger; compareTo[org.jgrapht.util.ModifiableInteger]; int; org.jgrapht.util.ModifiableInteger; compareTo[java.lang.Object]; int; null; this>
<java.lang.Integer; valueOf[int]; java.lang.Integer; org.jgrapht.util.ModifiableInteger; toInteger[]; java.lang.Integer; null; Integer>
<java.lang.String; valueOf[int]; java.lang.String; org.jgrapht.util.ModifiableInteger; toString[]; java.lang.String; null; String>
<java.lang.Math; min[double, double]; double; java.lang.Object; combine[double, double]; double; null; Math>
<java.lang.Math; max[double, double]; double; java.lang.Object; combine[double, double]; double; null; Math>
<java.lang.Double; toString[double]; java.lang.String; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; Double>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.Double; toString[double]; java.lang.String; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; Double>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.Double; toString[double]; java.lang.String; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; Double>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.Integer; toString[int]; java.lang.String; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; Integer>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.Double; toString[double]; java.lang.String; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; Double>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.Double; toString[double]; java.lang.String; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; Double>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.Double; toString[double]; java.lang.String; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; Double>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; append[char]; java.lang.StringBuffer; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.util.FibonacciHeapNode; toString[]; java.lang.String; null; buf>
<java.util.AbstractSet; equals[java.lang.Object]; boolean; org.jgrapht.util.ArrayUnenforcedSet; equals[java.lang.Object]; boolean; null; new SetForEquality()>
<java.util.AbstractSet; hashCode[]; int; org.jgrapht.util.ArrayUnenforcedSet; hashCode[]; int; null; new SetForEquality()>
<java.util.ArrayList; iterator[]; java.util.Iterator<E>; org.jgrapht.util.ArrayUnenforcedSet.SetForEquality; iterator[]; java.util.Iterator<E>; null; ArrayUnenforcedSet.this>
<java.util.ArrayList; size[]; int; org.jgrapht.util.ArrayUnenforcedSet.SetForEquality; size[]; int; null; ArrayUnenforcedSet.this>
<org.jgrapht.util.PrefetchIterator$NextElementFunctor; nextElement[]; E; org.jgrapht.util.PrefetchIterator; getNextElementFromInnerFunctor[]; E; null; this.innerEnum>
<org.jgrapht.util.PrefetchIterator; getNextElementFromInnerFunctor[]; E; org.jgrapht.util.PrefetchIterator; nextElement[]; E; null; this>
<org.jgrapht.util.PrefetchIterator; getNextElementFromInnerFunctor[]; E; org.jgrapht.util.PrefetchIterator; hasMoreElements[]; boolean; null; this>
<org.jgrapht.util.PrefetchIterator; hasMoreElements[]; boolean; org.jgrapht.util.PrefetchIterator; isEnumerationStartedEmpty[]; boolean; null; this>
<org.jgrapht.util.PrefetchIterator; hasMoreElements[]; boolean; org.jgrapht.util.PrefetchIterator; hasNext[]; boolean; null; this>
<org.jgrapht.util.PrefetchIterator; nextElement[]; E; org.jgrapht.util.PrefetchIterator; next[]; E; null; this>
<org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter; setDefaultVertexAttributes[org.jgrapht.ext.AttributeMap]; void; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter; setDefaultEdgeAttributes[org.jgrapht.ext.AttributeMap]; void; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; this>
<org.jgrapht.ListenableGraph; addGraphListener[org.jgrapht.event.GraphListener<V,E>]; void; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; g>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; jGraphTGraph.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; iterator[]; jGraphTGraph>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; i>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedVertex[V]; void; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; this>
<java.util.Iterator; next[]; V; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; i>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; jGraphTGraph.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; iterator[]; jGraphTGraph>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; i>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; this>
<java.util.Iterator; next[]; E; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; i>
<not found; addGraphModelListener[]; not found; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; this>
<not found; setLineEnd[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; setEndFill[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; setEndSize[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; setForeground[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<java.awt.Color; decode[java.lang.String]; java.awt.Color; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; Color>
<not found; setFont[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; deriveFont[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; GraphConstants.DEFAULTFONT>
<not found; setLineColor[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<java.awt.Color; decode[java.lang.String]; java.awt.Color; org.jgrapht.ext.JGraphModelAdapter; createDefaultEdgeAttributes[org.jgrapht.Graph<V,E>]; org.jgrapht.ext.AttributeMap; null; Color>
<java.awt.Color; decode[java.lang.String]; java.awt.Color; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; Color>
<not found; setBounds[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; setBorder[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<javax.swing.BorderFactory; createRaisedBevelBorder[]; javax.swing.border.Border; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; BorderFactory>
<not found; setBackground[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; setForeground[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; setFont[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; deriveFont[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; GraphConstants.DEFAULTFONT>
<not found; setOpaque[]; not found; org.jgrapht.ext.JGraphModelAdapter; createDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; null; GraphConstants>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; getEdgeCell[E]; org.jgrapht.ext.DefaultEdge; null; edgeToCell>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; getVertexCell[java.lang.Object]; org.jgrapht.ext.DefaultGraphCell; null; vertexToCell>
<org.jgrapht.ext.JGraphModelAdapter; getVertexCell[java.lang.Object]; org.jgrapht.ext.DefaultGraphCell; org.jgrapht.ext.JGraphModelAdapter; getVertexPort[java.lang.Object]; org.jgrapht.ext.DefaultPort; null; this>
<not found; getChildAt[]; not found; org.jgrapht.ext.JGraphModelAdapter; getVertexPort[java.lang.Object]; org.jgrapht.ext.DefaultPort; null; vertexCell>
<org.jgrapht.ext.JGraphModelAdapter; isDangling[org.jgraph.graph.Edge]; boolean; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; this>
<not found; containsKey[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; cellToEdge>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedEdge[org.jgraph.graph.Edge]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; this>
<not found; containsKey[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; cellToEdge>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; cellToEdge>
<not found; getSourceVertex[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; this>
<not found; getTargetVertex[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; this>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; cellToVertex>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; cellToVertex>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; getEdgeSource[E]; V; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; jtGraph>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; getEdgeTarget[E]; V; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; jtGraph>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedEdge[org.jgraph.graph.Edge]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter; isDangling[org.jgraph.graph.Edge]; boolean; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; this>
<not found; getSourceVertex[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; this>
<not found; getTargetVertex[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; this>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; cellToVertex>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; cellToVertex>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; addEdge[V, V]; E; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; jtGraph>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; cellToEdge>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; edgeToCell>
<org.jgrapht.ext.JGraphModelAdapter; internalRemoveCell[org.jgrapht.ext.GraphCell]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; this>
<java.io.PrintStream; println[java.lang.String]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; null; System.err>
<not found; getUserObject[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; null; ((DefaultGraphCell)jVertex)>
<not found; toString[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; null; jVertex>
<not found; containsKey[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; null; vertexToCell>
<java.io.PrintStream; println[char[]]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; null; System.err>
<org.jgrapht.ext.JGraphModelAdapter; internalRemoveCell[org.jgrapht.ext.GraphCell]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; addVertex[V]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; null; jtGraph>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; null; cellToVertex>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; null; vertexToCell>
<not found; containsKey[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedEdge[org.jgraph.graph.Edge]; void; null; cellToEdge>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedEdge[org.jgraph.graph.Edge]; void; null; cellToEdge>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; removeEdge[E]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedEdge[org.jgraph.graph.Edge]; void; null; jtGraph>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedEdge[org.jgraph.graph.Edge]; void; null; cellToEdge>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedEdge[org.jgraph.graph.Edge]; void; null; edgeToCell>
<not found; containsKey[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; cellToVertex>
<not found; get[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; cellToVertex>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; edgesOf[V]; java.util.Set<E>; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; jtGraph>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; jtIncidentEdges>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; removeAllEdges[java.util.Collection<E>]; boolean; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; jtGraph>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; removeVertex[V]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; jtGraph>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; cellToVertex>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; vertexToCell>
<org.jgrapht.ext.JGraphModelAdapter$CellFactory; createEdgeCell[E]; org.jgrapht.ext.DefaultEdge; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; cellFactory>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; edgeToCell>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; cellToEdge>
<not found; connect[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; cs>
<org.jgrapht.ext.JGraphModelAdapter; getVertexPort[java.lang.Object]; org.jgrapht.ext.DefaultPort; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; getEdgeSource[E]; V; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; jtGraph>
<org.jgrapht.ext.JGraphModelAdapter; getVertexPort[java.lang.Object]; org.jgrapht.ext.DefaultPort; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$ShieldedGraph; getEdgeTarget[E]; V; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; jtGraph>
<org.jgrapht.ext.JGraphModelAdapter; internalInsertCell[org.jgrapht.ext.GraphCell, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.ConnectionSet]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter; createEdgeAttributeMap[org.jgrapht.ext.DefaultEdge]; org.jgrapht.ext.AttributeMap; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$CellFactory; createVertexCell[V]; org.jgrapht.ext.DefaultGraphCell; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedVertex[V]; void; null; cellFactory>
<not found; add[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedVertex[V]; void; null; vertexCell>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedVertex[V]; void; null; vertexToCell>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedVertex[V]; void; null; cellToVertex>
<org.jgrapht.ext.JGraphModelAdapter; internalInsertCell[org.jgrapht.ext.GraphCell, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.ConnectionSet]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedVertex[V]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter; createVertexAttributeMap[org.jgrapht.ext.GraphCell]; org.jgrapht.ext.AttributeMap; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedVertex[V]; void; null; this>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; vertexToCell>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; cellToVertex>
<not found; getChildren[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; vertexCell>
<not found; isPort[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; this>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; ports>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; this>
<java.util.List; toArray[]; java.lang.Object[]; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; ports>
<org.jgrapht.ext.JGraphModelAdapter; internalRemoveCell[org.jgrapht.ext.GraphCell]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; this>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemovedEdge[E]; void; null; edgeToCell>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemovedEdge[E]; void; null; cellToEdge>
<org.jgrapht.ext.JGraphModelAdapter; internalRemoveCell[org.jgrapht.ext.GraphCell]; void; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemovedEdge[E]; void; null; this>
<not found; getSourceVertex[]; not found; org.jgrapht.ext.JGraphModelAdapter; isDangling[org.jgraph.graph.Edge]; boolean; null; this>
<not found; getTargetVertex[]; not found; org.jgrapht.ext.JGraphModelAdapter; isDangling[org.jgraph.graph.Edge]; boolean; null; this>
<not found; containsKey[]; not found; org.jgrapht.ext.JGraphModelAdapter; isDangling[org.jgraph.graph.Edge]; boolean; null; cellToVertex>
<not found; containsKey[]; not found; org.jgrapht.ext.JGraphModelAdapter; isDangling[org.jgraph.graph.Edge]; boolean; null; cellToVertex>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; createEdgeAttributeMap[org.jgrapht.ext.DefaultEdge]; org.jgrapht.ext.AttributeMap; null; attrs>
<not found; clone[]; not found; org.jgrapht.ext.JGraphModelAdapter; createEdgeAttributeMap[org.jgrapht.ext.DefaultEdge]; org.jgrapht.ext.AttributeMap; null; getDefaultEdgeAttributes()>
<org.jgrapht.ext.JGraphModelAdapter; getDefaultEdgeAttributes[]; org.jgrapht.ext.AttributeMap; org.jgrapht.ext.JGraphModelAdapter; createEdgeAttributeMap[org.jgrapht.ext.DefaultEdge]; org.jgrapht.ext.AttributeMap; clone[]; this>
<not found; put[]; not found; org.jgrapht.ext.JGraphModelAdapter; createVertexAttributeMap[org.jgrapht.ext.GraphCell]; org.jgrapht.ext.AttributeMap; null; attrs>
<not found; clone[]; not found; org.jgrapht.ext.JGraphModelAdapter; createVertexAttributeMap[org.jgrapht.ext.GraphCell]; org.jgrapht.ext.AttributeMap; null; getDefaultVertexAttributes()>
<org.jgrapht.ext.JGraphModelAdapter; getDefaultVertexAttributes[]; org.jgrapht.ext.AttributeMap; org.jgrapht.ext.JGraphModelAdapter; createVertexAttributeMap[org.jgrapht.ext.GraphCell]; org.jgrapht.ext.AttributeMap; clone[]; this>
<not found; add[]; not found; org.jgrapht.ext.JGraphModelAdapter; internalInsertCell[org.jgrapht.ext.GraphCell, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.ConnectionSet]; void; null; jCellsBeingAdded>
<not found; insert[]; not found; org.jgrapht.ext.JGraphModelAdapter; internalInsertCell[org.jgrapht.ext.GraphCell, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.ConnectionSet]; void; null; this>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; internalInsertCell[org.jgrapht.ext.GraphCell, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.ConnectionSet]; void; null; jCellsBeingAdded>
<not found; add[]; not found; org.jgrapht.ext.JGraphModelAdapter; internalRemoveCell[org.jgrapht.ext.GraphCell]; void; null; jCellsBeingRemoved>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; internalRemoveCell[org.jgrapht.ext.GraphCell]; void; null; this>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter; internalRemoveCell[org.jgrapht.ext.GraphCell]; void; null; jCellsBeingRemoved>
<not found; getChange[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; e>
<not found; getRemoved[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; change>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; handleRemovedEdges[java.util.List<java.lang.Object>]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; filterEdges[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; handleRemovedVertices[java.util.List<java.lang.Object>]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; filterVertices[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<not found; getInserted[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; change>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; handleInsertedVertices[java.util.List<java.lang.Object>]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; filterVertices[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; handleInsertedEdges[java.util.List<java.lang.Object>]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; filterEdges[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<not found; getChanged[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; change>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; handleChangedEdges[java.util.List<java.lang.Object>]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<org.jgrapht.ext.JGraphModelAdapter$JGraphListener; filterEdges[java.lang.Object[]]; java.util.List<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; graphChanged[org.jgrapht.ext.GraphModelEvent]; void; null; this>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; filterEdges[java.lang.Object[]]; java.util.List<java.lang.Object>; null; jEdges>
<not found; isLeaf[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; filterVertices[java.lang.Object[]]; java.util.List<java.lang.Object>; null; graphCell>
<not found; getFirstChild[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; filterVertices[java.lang.Object[]]; java.util.List<java.lang.Object>; null; graphCell>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; filterVertices[java.lang.Object[]]; java.util.List<java.lang.Object>; null; jVertices>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; filterVertices[java.lang.Object[]]; java.util.List<java.lang.Object>; null; jVertices>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleChangedEdges[java.util.List<java.lang.Object>]; void; null; jEdges>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleChangedEdges[java.util.List<java.lang.Object>]; void; null; i>
<java.util.Iterator; next[]; java.lang.Object; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleChangedEdges[java.util.List<java.lang.Object>]; void; null; i>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphChangedEdge[org.jgraph.graph.Edge]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleChangedEdges[java.util.List<java.lang.Object>]; void; null; this>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedEdges[java.util.List<java.lang.Object>]; void; null; jEdges>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedEdges[java.util.List<java.lang.Object>]; void; null; i>
<java.util.Iterator; next[]; java.lang.Object; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedEdges[java.util.List<java.lang.Object>]; void; null; i>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedEdges[java.util.List<java.lang.Object>]; void; null; jCellsBeingAdded>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedEdge[org.jgraph.graph.Edge]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedEdges[java.util.List<java.lang.Object>]; void; null; this>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedVertices[java.util.List<java.lang.Object>]; void; null; jVertices>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedVertices[java.util.List<java.lang.Object>]; void; null; i>
<java.util.Iterator; next[]; java.lang.Object; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedVertices[java.util.List<java.lang.Object>]; void; null; i>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedVertices[java.util.List<java.lang.Object>]; void; null; jCellsBeingAdded>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphInsertedVertex[org.jgrapht.ext.GraphCell]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedVertices[java.util.List<java.lang.Object>]; void; null; this>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedEdges[java.util.List<java.lang.Object>]; void; null; jEdges>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedEdges[java.util.List<java.lang.Object>]; void; null; i>
<java.util.Iterator; next[]; java.lang.Object; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedEdges[java.util.List<java.lang.Object>]; void; null; i>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedEdges[java.util.List<java.lang.Object>]; void; null; jCellsBeingRemoved>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedEdge[org.jgraph.graph.Edge]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedEdges[java.util.List<java.lang.Object>]; void; null; this>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedVertices[java.util.List<java.lang.Object>]; void; null; jVertices>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedVertices[java.util.List<java.lang.Object>]; void; null; i>
<java.util.Iterator; next[]; java.lang.Object; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedVertices[java.util.List<java.lang.Object>]; void; null; i>
<not found; remove[]; not found; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedVertices[java.util.List<java.lang.Object>]; void; null; jCellsBeingRemoved>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedVertices[java.util.List<java.lang.Object>]; void; null; this>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; jtElementsBeingAdded>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedEdge[E]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; jtElementsBeingRemoved>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemovedEdge[E]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.event.GraphVertexChangeEvent; getVertex[]; V; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; vertexAdded[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; e>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; vertexAdded[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; jtElementsBeingAdded>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphTAddedVertex[V]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; vertexAdded[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; this>
<org.jgrapht.event.GraphVertexChangeEvent; getVertex[]; V; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; e>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; jtElementsBeingRemoved>
<org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; this>
<org.jgrapht.Graph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; null; graph>
<org.jgrapht.EdgeFactory; createEdge[V, V]; E; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addEdge[V, V]; E; null; graph.getEdgeFactory()>
<org.jgrapht.Graph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addEdge[V, V]; E; createEdge[V, V]; graph>
<java.util.Set; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addEdge[V, V]; E; null; jtElementsBeingAdded>
<org.jgrapht.Graph; addEdge[V, V, E]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addEdge[V, V]; E; null; graph>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addEdge[V, V]; E; null; jtElementsBeingAdded>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; getEdgeSource[E]; V; null; graph>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; getEdgeTarget[E]; V; null; graph>
<java.util.Set; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addVertex[V]; void; null; jtElementsBeingAdded>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addVertex[V]; void; null; graph>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addVertex[V]; void; null; jtElementsBeingAdded>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; edgesOf[V]; java.util.Set<E>; null; graph>
<org.jgrapht.Graph; removeAllEdges[java.util.Collection<? extends E>]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeAllEdges[java.util.Collection<E>]; boolean; null; graph>
<java.util.Set; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeEdge[E]; void; null; jtElementsBeingRemoved>
<org.jgrapht.Graph; removeEdge[E]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeEdge[E]; void; null; graph>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeEdge[E]; void; null; jtElementsBeingRemoved>
<java.util.Set; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeVertex[V]; void; null; jtElementsBeingRemoved>
<org.jgrapht.Graph; removeVertex[V]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeVertex[V]; void; null; graph>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeVertex[V]; void; null; jtElementsBeingRemoved>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportHeader[java.io.PrintWriter]; void; null; out>
<org.jgrapht.ext.GmlExporter; quoted[java.lang.String]; java.lang.String; org.jgrapht.ext.GmlExporter; exportHeader[java.io.PrintWriter]; void; null; this>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportHeader[java.io.PrintWriter]; void; null; out>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; g>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; vertexIDProvider>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; from>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; vertexLabelProvider>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.GmlExporter; quoted[java.lang.String]; java.lang.String; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; this>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; g>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.EdgeNameProvider; getEdgeName[E]; java.lang.String; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; edgeIDProvider>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; vertexIDProvider>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; g>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; vertexIDProvider>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; g>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; edge>
<org.jgrapht.ext.EdgeNameProvider; getEdgeName[E]; java.lang.String; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; edgeLabelProvider>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.GmlExporter; quoted[java.lang.String]; java.lang.String; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; this>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; g>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; vertexIDProvider>
<org.jgrapht.ext.GmlExporter; exportHeader[java.io.PrintWriter]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; this>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; out>
<org.jgrapht.ext.GmlExporter; quoted[java.lang.String]; java.lang.String; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; this>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; out>
<org.jgrapht.ext.GmlExporter; exportVertices[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; this>
<org.jgrapht.ext.GmlExporter; exportEdges[java.io.PrintWriter, org.jgrapht.Graph<V,E>]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; this>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; out>
<java.io.PrintWriter; flush[]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; null; out>
<org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>, boolean]; void; org.jgrapht.ext.GmlExporter; export[java.io.Writer, org.jgrapht.DirectedGraph<V,E>]; void; null; this>
<java.lang.Integer; toString[int]; java.lang.String; org.jgrapht.ext.GmlExporter; setPrintLabels[java.lang.Integer]; void; null; Integer>
<java.util.Map; clear[]; void; org.jgrapht.ext.IntegerEdgeNameProvider; clear[]; void; null; idMap>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.ext.IntegerEdgeNameProvider; getEdgeName[E]; java.lang.String; null; idMap>
<java.util.Map; put[E, java.lang.Integer]; java.lang.Integer; org.jgrapht.ext.IntegerEdgeNameProvider; getEdgeName[E]; java.lang.String; null; idMap>
<java.lang.Integer; toString[]; java.lang.String; org.jgrapht.ext.IntegerEdgeNameProvider; getEdgeName[E]; java.lang.String; null; id>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; iterator[]; g>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; i>
<org.jgrapht.ext.VisioExporter; exportVertex[java.io.PrintStream, V]; void; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; this>
<java.util.Iterator; next[]; V; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; i>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; g.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; iterator[]; g>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; i>
<org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; this>
<java.util.Iterator; next[]; E; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; i>
<java.io.PrintStream; flush[]; void; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; vertexNameProvider>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; vertexNameProvider>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; g>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportEdge[java.io.PrintStream, E, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.VisioExporter; exportVertex[java.io.PrintStream, V]; void; null; vertexNameProvider>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportVertex[java.io.PrintStream, V]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportVertex[java.io.PrintStream, V]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportVertex[java.io.PrintStream, V]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportVertex[java.io.PrintStream, V]; void; null; out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.ext.VisioExporter; exportVertex[java.io.PrintStream, V]; void; null; out>
<javax.xml.transform.TransformerFactory; newInstance[]; javax.xml.transform.TransformerFactory; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; SAXTransformerFactory>
<javax.xml.transform.sax.SAXTransformerFactory; newTransformerHandler[]; javax.xml.transform.sax.TransformerHandler; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; factory>
<javax.xml.transform.sax.TransformerHandler; getTransformer[]; javax.xml.transform.Transformer; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<javax.xml.transform.Transformer; setOutputProperty[java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; serializer>
<javax.xml.transform.Transformer; setOutputProperty[java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; serializer>
<javax.xml.transform.sax.TransformerHandler; setResult[javax.xml.transform.Result]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; startDocument[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; startPrefixMapping[java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.ContentHandler; startElement[java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; endPrefixMapping[java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.helpers.AttributesImpl; clear[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.ContentHandler; startElement[java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; endElement[java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.helpers.AttributesImpl; clear[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.ContentHandler; startElement[java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; endElement[java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.helpers.AttributesImpl; clear[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.ContentHandler; startElement[java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; g>
<org.xml.sax.helpers.AttributesImpl; clear[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; vertexIDProvider>
<org.xml.sax.ContentHandler; startElement[java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.helpers.AttributesImpl; clear[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.ContentHandler; startElement[java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; vertexLabelProvider>
<org.xml.sax.ContentHandler; characters[char[], int, int]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<java.lang.String; toCharArray[]; char[]; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; vertexLabel>
<java.lang.String; length[]; int; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; vertexLabel>
<org.xml.sax.ContentHandler; endElement[java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; endElement[java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; g>
<org.xml.sax.helpers.AttributesImpl; clear[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.jgrapht.ext.EdgeNameProvider; getEdgeName[E]; java.lang.String; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; edgeIDProvider>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; vertexIDProvider>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; g>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; vertexIDProvider>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; g>
<org.xml.sax.ContentHandler; startElement[java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.helpers.AttributesImpl; clear[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.helpers.AttributesImpl; addAttribute[java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; attr>
<org.xml.sax.ContentHandler; startElement[java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.jgrapht.ext.EdgeNameProvider; getEdgeName[E]; java.lang.String; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; edgeLabelProvider>
<org.xml.sax.ContentHandler; characters[char[], int, int]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<java.lang.String; toCharArray[]; char[]; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; edgeLabel>
<java.lang.String; length[]; int; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; edgeLabel>
<org.xml.sax.ContentHandler; endElement[java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; endElement[java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; endElement[java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; endElement[java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<org.xml.sax.ContentHandler; endDocument[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; handler>
<java.io.PrintWriter; flush[]; void; org.jgrapht.ext.GraphMLExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; g>
<java.io.PrintWriter; print[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.DOTExporter; getVertexID[V]; java.lang.String; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; this>
<java.io.PrintWriter; print[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; vertexLabelProvider>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.ext.DOTExporter; getVertexID[V]; java.lang.String; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.ext.DOTExporter; getVertexID[V]; java.lang.String; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; g>
<java.io.PrintWriter; print[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintWriter; print[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.EdgeNameProvider; getEdgeName[E]; java.lang.String; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; edgeLabelProvider>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<java.io.PrintWriter; flush[]; void; org.jgrapht.ext.DOTExporter; export[java.io.Writer, org.jgrapht.Graph<V,E>]; void; null; out>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.DOTExporter; getVertexID[V]; java.lang.String; null; vertexIDProvider>
<java.lang.String; matches[java.lang.String]; boolean; org.jgrapht.ext.DOTExporter; getVertexID[V]; java.lang.String; null; idCandidate>
<java.lang.String; matches[java.lang.String]; boolean; org.jgrapht.ext.DOTExporter; getVertexID[V]; java.lang.String; null; idCandidate>
<java.lang.String; matches[java.lang.String]; boolean; org.jgrapht.ext.DOTExporter; getVertexID[V]; java.lang.String; null; idCandidate>
<java.lang.String; matches[java.lang.String]; boolean; org.jgrapht.ext.DOTExporter; getVertexID[V]; java.lang.String; null; idCandidate>
<java.util.Map; clear[]; void; org.jgrapht.ext.IntegerNameProvider; clear[]; void; null; idMap>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.ext.IntegerNameProvider; getVertexName[V]; java.lang.String; null; idMap>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.ext.IntegerNameProvider; getVertexName[V]; java.lang.String; null; idMap>
<java.lang.Integer; toString[]; java.lang.String; org.jgrapht.ext.IntegerNameProvider; getVertexName[V]; java.lang.String; null; id>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.ext.StringNameProvider; getVertexName[V]; java.lang.String; null; vertex>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.ext.StringEdgeNameProvider; getEdgeName[E]; java.lang.String; null; edge>
<java.io.PrintWriter; println[java.lang.String]; void; org.jgrapht.ext.MatrixExporter; println[java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String]; void; null; out>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; nameProvider>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; Graphs>
<java.io.PrintWriter; flush[]; void; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; out>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.DirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.DirectedGraph<V,E>]; void; null; nameProvider>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.DirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.DirectedGraph<V,E>]; void; null; this>
<org.jgrapht.Graphs; successorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.DirectedGraph<V,E>]; void; null; Graphs>
<java.io.PrintWriter; flush[]; void; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrix[java.io.Writer, org.jgrapht.DirectedGraph<V,E>]; void; null; out>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; nameProvider>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; nameProvider>
<java.util.Map; get[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; counts>
<java.util.Map; put[java.lang.String, org.jgrapht.util.ModifiableInteger]; org.jgrapht.util.ModifiableInteger; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; counts>
<org.jgrapht.util.ModifiableInteger; increment[]; void; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; count>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; from>
<org.jgrapht.util.ModifiableInteger; increment[]; void; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; count>
<java.util.Map; entrySet[]; java.util.Set<java.util.Map.Entry<java.lang.String,org.jgrapht.util.ModifiableInteger>>; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; counts>
<java.util.Map$Entry; getKey[]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; entry>
<java.util.Map$Entry; getValue[]; org.jgrapht.util.ModifiableInteger; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; entry>
<org.jgrapht.ext.MatrixExporter; println[java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; this>
<org.jgrapht.util.ModifiableInteger; toString[]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; count>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; nameProvider>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; nameProvider>
<org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; Graphs>
<org.jgrapht.ext.MatrixExporter; println[java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<java.lang.Integer; toString[int]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; Integer>
<java.util.List; size[]; int; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; neighbors>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; nameProvider>
<org.jgrapht.ext.MatrixExporter; println[java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<java.io.PrintWriter; flush[]; void; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; out>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; nameProvider>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; nameProvider>
<org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; Graphs>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; neighbors>
<org.jgrapht.ext.MatrixExporter; println[java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<org.jgrapht.ext.MatrixExporter; println[java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<org.jgrapht.ext.VertexNameProvider; getVertexName[V]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; nameProvider>
<java.lang.Math; sqrt[double]; double; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; Math>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; g>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; g>
<org.jgrapht.ext.MatrixExporter; println[java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String]; void; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<java.lang.Double; toString[double]; java.lang.String; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; Double>
<java.io.PrintWriter; flush[]; void; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; out>
<org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; org.jgrapht.traverse.TopologicalOrderIterator; TopologicalOrderIterator[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; void; null; this>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; TopologicalOrderIterator[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; void; null; dg.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.traverse.TopologicalOrderIterator; TopologicalOrderIterator[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; void; isEmpty[]; dg>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; TopologicalOrderIterator[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; void; null; queue>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; isConnectedComponentExhausted[]; boolean; null; queue>
<org.jgrapht.traverse.CrossComponentIterator; putSeenData[V, java.lang.Object]; java.lang.Object; org.jgrapht.traverse.TopologicalOrderIterator; encounterVertex[V, E]; void; null; this>
<org.jgrapht.traverse.TopologicalOrderIterator; decrementInDegree[V]; void; org.jgrapht.traverse.TopologicalOrderIterator; encounterVertex[V, E]; void; null; this>
<org.jgrapht.traverse.TopologicalOrderIterator; decrementInDegree[V]; void; org.jgrapht.traverse.TopologicalOrderIterator; encounterVertexAgain[V, E]; void; null; this>
<java.util.Queue; remove[]; V; org.jgrapht.traverse.TopologicalOrderIterator; provideNextVertex[]; V; null; queue>
<java.util.Map; get[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.traverse.TopologicalOrderIterator; decrementInDegree[V]; void; null; inDegreeMap>
<java.util.Queue; offer[V]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; decrementInDegree[V]; void; null; queue>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; dg.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; iterator[]; dg>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; i>
<java.util.Iterator; next[]; V; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; i>
<org.jgrapht.DirectedGraph; inDegreeOf[V]; int; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; dg>
<java.util.Map; put[V, org.jgrapht.util.ModifiableInteger]; org.jgrapht.util.ModifiableInteger; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; inDegreeMap>
<java.util.Queue; offer[V]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; queue>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; queue>
<java.util.Queue; peek[]; V; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; queue>
<java.util.LinkedList; getFirst[]; T; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; element[]; T; null; this>
<java.util.LinkedList; add[T]; boolean; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; offer[T]; boolean; null; this>
<java.util.AbstractCollection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; peek[]; T; null; this>
<java.util.LinkedList; getFirst[]; T; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; peek[]; T; null; this>
<java.util.AbstractCollection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; poll[]; T; null; this>
<java.util.LinkedList; removeFirst[]; T; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; poll[]; T; null; this>
<java.util.LinkedList; removeFirst[]; T; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; remove[]; T; null; this>
<java.util.List; contains[java.lang.Object]; boolean; org.jgrapht.traverse.AbstractGraphIterator; addTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; add[org.jgrapht.event.TraversalListener<V,E>]; boolean; org.jgrapht.traverse.AbstractGraphIterator; addTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; size[]; int; org.jgrapht.traverse.AbstractGraphIterator; addTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; remove[java.lang.Object]; boolean; org.jgrapht.traverse.AbstractGraphIterator; removeTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; size[]; int; org.jgrapht.traverse.AbstractGraphIterator; removeTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireConnectedComponentFinished[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; null; traversalListeners>
<org.jgrapht.event.TraversalListener; connectedComponentFinished[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; org.jgrapht.traverse.AbstractGraphIterator; fireConnectedComponentFinished[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; null; l>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireConnectedComponentStarted[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; null; traversalListeners>
<org.jgrapht.event.TraversalListener; connectedComponentStarted[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; org.jgrapht.traverse.AbstractGraphIterator; fireConnectedComponentStarted[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; null; l>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireEdgeTraversed[org.jgrapht.event.EdgeTraversalEvent<V,E>]; void; null; traversalListeners>
<org.jgrapht.event.TraversalListener; edgeTraversed[org.jgrapht.event.EdgeTraversalEvent<V,E>]; void; org.jgrapht.traverse.AbstractGraphIterator; fireEdgeTraversed[org.jgrapht.event.EdgeTraversalEvent<V,E>]; void; null; l>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireVertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; traversalListeners>
<org.jgrapht.event.TraversalListener; vertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; org.jgrapht.traverse.AbstractGraphIterator; fireVertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; l>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireVertexFinished[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; traversalListeners>
<org.jgrapht.event.TraversalListener; vertexFinished[org.jgrapht.event.VertexTraversalEvent<V>]; void; org.jgrapht.traverse.AbstractGraphIterator; fireVertexFinished[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; l>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.DepthFirstIterator; isConnectedComponentExhausted[]; boolean; null; stack>
<java.util.Deque; getLast[]; java.lang.Object; org.jgrapht.traverse.DepthFirstIterator; isConnectedComponentExhausted[]; boolean; null; stack>
<java.util.Deque; removeLast[]; java.lang.Object; org.jgrapht.traverse.DepthFirstIterator; isConnectedComponentExhausted[]; boolean; null; stack>
<org.jgrapht.traverse.DepthFirstIterator; recordFinish[]; void; org.jgrapht.traverse.DepthFirstIterator; isConnectedComponentExhausted[]; boolean; null; this>
<org.jgrapht.traverse.CrossComponentIterator; putSeenData[V, org.jgrapht.traverse.CrossComponentIterator.VisitColor]; org.jgrapht.traverse.CrossComponentIterator.VisitColor; org.jgrapht.traverse.DepthFirstIterator; encounterVertex[V, E]; void; null; this>
<java.util.Deque; addLast[java.lang.Object]; void; org.jgrapht.traverse.DepthFirstIterator; encounterVertex[V, E]; void; null; stack>
<org.jgrapht.traverse.CrossComponentIterator; getSeenData[V]; org.jgrapht.traverse.CrossComponentIterator.VisitColor; org.jgrapht.traverse.DepthFirstIterator; encounterVertexAgain[V, E]; void; null; this>
<java.util.Deque; removeLastOccurrence[java.lang.Object]; boolean; org.jgrapht.traverse.DepthFirstIterator; encounterVertexAgain[V, E]; void; null; stack>
<java.util.Deque; addLast[java.lang.Object]; void; org.jgrapht.traverse.DepthFirstIterator; encounterVertexAgain[V, E]; void; null; stack>
<java.util.Deque; removeLast[]; java.lang.Object; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; stack>
<org.jgrapht.traverse.DepthFirstIterator; recordFinish[]; void; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; this>
<org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<V>]; V; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; TypeUtil>
<java.util.Deque; addLast[java.lang.Object]; void; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; stack>
<java.util.Deque; addLast[java.lang.Object]; void; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; stack>
<org.jgrapht.traverse.CrossComponentIterator; putSeenData[V, org.jgrapht.traverse.CrossComponentIterator.VisitColor]; org.jgrapht.traverse.CrossComponentIterator.VisitColor; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; this>
<org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<V>]; V; org.jgrapht.traverse.DepthFirstIterator; recordFinish[]; void; null; TypeUtil>
<java.util.Deque; removeLast[]; java.lang.Object; org.jgrapht.traverse.DepthFirstIterator; recordFinish[]; void; null; stack>
<org.jgrapht.traverse.CrossComponentIterator; putSeenData[V, org.jgrapht.traverse.CrossComponentIterator.VisitColor]; org.jgrapht.traverse.CrossComponentIterator.VisitColor; org.jgrapht.traverse.DepthFirstIterator; recordFinish[]; void; null; this>
<org.jgrapht.traverse.CrossComponentIterator; finishVertex[V]; void; org.jgrapht.traverse.DepthFirstIterator; recordFinish[]; void; null; this>
<org.jgrapht.traverse.ClosestFirstIterator; checkRadiusTraversal[boolean]; void; org.jgrapht.traverse.ClosestFirstIterator; ClosestFirstIterator[org.jgrapht.Graph<V,E>, V, double]; void; null; this>
<org.jgrapht.traverse.AbstractGraphIterator; isCrossComponentTraversal[]; boolean; org.jgrapht.traverse.ClosestFirstIterator; ClosestFirstIterator[org.jgrapht.Graph<V,E>, V, double]; void; null; this>
<org.jgrapht.traverse.ClosestFirstIterator; checkRadiusTraversal[boolean]; void; org.jgrapht.traverse.ClosestFirstIterator; setCrossComponentTraversal[boolean]; void; null; this>
<org.jgrapht.traverse.CrossComponentIterator; getSeenData[V]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; org.jgrapht.traverse.ClosestFirstIterator; getShortestPathLength[V]; double; null; this>
<org.jgrapht.util.FibonacciHeapNode; getKey[]; double; org.jgrapht.traverse.ClosestFirstIterator; getShortestPathLength[V]; double; null; node>
<org.jgrapht.traverse.CrossComponentIterator; getSeenData[V]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; org.jgrapht.traverse.ClosestFirstIterator; getSpanningTreeEdge[V]; E; null; this>
<org.jgrapht.util.FibonacciHeapNode; getData[]; org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>; org.jgrapht.traverse.ClosestFirstIterator; getSpanningTreeEdge[V]; E; null; node>
<org.jgrapht.util.FibonacciHeap; size[]; int; org.jgrapht.traverse.ClosestFirstIterator; isConnectedComponentExhausted[]; boolean; null; heap>
<org.jgrapht.util.FibonacciHeapNode; getKey[]; double; org.jgrapht.traverse.ClosestFirstIterator; isConnectedComponentExhausted[]; boolean; null; heap.min()>
<org.jgrapht.util.FibonacciHeap; min[]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; org.jgrapht.traverse.ClosestFirstIterator; isConnectedComponentExhausted[]; boolean; getKey[]; heap>
<org.jgrapht.util.FibonacciHeap; clear[]; void; org.jgrapht.traverse.ClosestFirstIterator; isConnectedComponentExhausted[]; boolean; null; heap>
<org.jgrapht.traverse.ClosestFirstIterator; createSeenData[V, E]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; org.jgrapht.traverse.ClosestFirstIterator; encounterVertex[V, E]; void; null; this>
<org.jgrapht.traverse.CrossComponentIterator; putSeenData[V, org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; org.jgrapht.traverse.ClosestFirstIterator; encounterVertex[V, E]; void; null; this>
<org.jgrapht.util.FibonacciHeap; insert[org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>, double]; void; org.jgrapht.traverse.ClosestFirstIterator; encounterVertex[V, E]; void; null; heap>
<org.jgrapht.util.FibonacciHeapNode; getKey[]; double; org.jgrapht.traverse.ClosestFirstIterator; encounterVertex[V, E]; void; null; node>
<org.jgrapht.traverse.CrossComponentIterator; getSeenData[V]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; org.jgrapht.traverse.ClosestFirstIterator; encounterVertexAgain[V, E]; void; null; this>
<org.jgrapht.util.FibonacciHeapNode; getData[]; org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>; org.jgrapht.traverse.ClosestFirstIterator; encounterVertexAgain[V, E]; void; null; node>
<org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; org.jgrapht.traverse.ClosestFirstIterator; encounterVertexAgain[V, E]; void; null; this>
<org.jgrapht.util.FibonacciHeapNode; getKey[]; double; org.jgrapht.traverse.ClosestFirstIterator; encounterVertexAgain[V, E]; void; null; node>
<org.jgrapht.util.FibonacciHeapNode; getData[]; org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>; org.jgrapht.traverse.ClosestFirstIterator; encounterVertexAgain[V, E]; void; null; node>
<org.jgrapht.util.FibonacciHeap; decreaseKey[org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>, double]; void; org.jgrapht.traverse.ClosestFirstIterator; encounterVertexAgain[V, E]; void; null; heap>
<org.jgrapht.util.FibonacciHeap; removeMin[]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; org.jgrapht.traverse.ClosestFirstIterator; provideNextVertex[]; V; null; heap>
<org.jgrapht.util.FibonacciHeapNode; getData[]; org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>; org.jgrapht.traverse.ClosestFirstIterator; provideNextVertex[]; V; null; node>
<org.jgrapht.util.FibonacciHeapNode; getData[]; org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>; org.jgrapht.traverse.ClosestFirstIterator; provideNextVertex[]; V; null; node>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.traverse.ClosestFirstIterator; assertNonNegativeEdge[E]; void; null; getGraph()>
<org.jgrapht.traverse.CrossComponentIterator; getGraph[]; org.jgrapht.Graph<V,E>; org.jgrapht.traverse.ClosestFirstIterator; assertNonNegativeEdge[E]; void; getEdgeWeight[E]; this>
<org.jgrapht.traverse.ClosestFirstIterator; assertNonNegativeEdge[E]; void; org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; null; this>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; null; Graphs>
<org.jgrapht.traverse.CrossComponentIterator; getGraph[]; org.jgrapht.Graph<V,E>; org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; null; this>
<org.jgrapht.traverse.CrossComponentIterator; getSeenData[V]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; null; this>
<org.jgrapht.util.FibonacciHeapNode; getKey[]; double; org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; null; otherEntry>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; null; getGraph()>
<org.jgrapht.traverse.CrossComponentIterator; getGraph[]; org.jgrapht.Graph<V,E>; org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; getEdgeWeight[E]; this>
<org.jgrapht.traverse.ClosestFirstIterator; calculatePathLength[V, E]; double; org.jgrapht.traverse.ClosestFirstIterator; createSeenData[V, E]; org.jgrapht.util.FibonacciHeapNode<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V,E>>; null; this>
<org.jgrapht.traverse.CrossComponentIterator; createGraphSpecifics[org.jgrapht.Graph<V,E>]; org.jgrapht.traverse.CrossComponentIterator.Specifics<V,E>; org.jgrapht.traverse.CrossComponentIterator; CrossComponentIterator[org.jgrapht.Graph<V,E>, V]; void; null; this>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.traverse.CrossComponentIterator; CrossComponentIterator[org.jgrapht.Graph<V,E>, V]; void; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.traverse.CrossComponentIterator; CrossComponentIterator[org.jgrapht.Graph<V,E>, V]; void; iterator[]; g>
<org.jgrapht.traverse.AbstractGraphIterator; setCrossComponentTraversal[boolean]; void; org.jgrapht.traverse.CrossComponentIterator; CrossComponentIterator[org.jgrapht.Graph<V,E>, V]; void; null; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.traverse.CrossComponentIterator; CrossComponentIterator[org.jgrapht.Graph<V,E>, V]; void; null; vertexIterator>
<java.util.Iterator; next[]; V; org.jgrapht.traverse.CrossComponentIterator; CrossComponentIterator[org.jgrapht.Graph<V,E>, V]; void; null; vertexIterator>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.traverse.CrossComponentIterator; CrossComponentIterator[org.jgrapht.Graph<V,E>, V]; void; null; g>
<org.jgrapht.traverse.CrossComponentIterator; encounterStartVertex[]; void; org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; null; this>
<org.jgrapht.traverse.CrossComponentIterator; isConnectedComponentExhausted[]; boolean; org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; null; this>
<org.jgrapht.traverse.AbstractGraphIterator; fireConnectedComponentFinished[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; null; this>
<org.jgrapht.traverse.AbstractGraphIterator; isCrossComponentTraversal[]; boolean; org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; null; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; null; vertexIterator>
<java.util.Iterator; next[]; V; org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; null; vertexIterator>
<org.jgrapht.traverse.CrossComponentIterator; isSeenVertex[java.lang.Object]; boolean; org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; null; this>
<org.jgrapht.traverse.CrossComponentIterator; encounterVertex[V, E]; void; org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; null; this>
<org.jgrapht.traverse.CrossComponentIterator; encounterStartVertex[]; void; org.jgrapht.traverse.CrossComponentIterator; next[]; V; null; this>
<org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; org.jgrapht.traverse.CrossComponentIterator; next[]; V; null; this>
<org.jgrapht.traverse.AbstractGraphIterator; fireConnectedComponentStarted[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; org.jgrapht.traverse.CrossComponentIterator; next[]; V; null; this>
<org.jgrapht.traverse.CrossComponentIterator; provideNextVertex[]; V; org.jgrapht.traverse.CrossComponentIterator; next[]; V; null; this>
<org.jgrapht.traverse.AbstractGraphIterator; fireVertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; org.jgrapht.traverse.CrossComponentIterator; next[]; V; null; this>
<org.jgrapht.traverse.CrossComponentIterator; createVertexTraversalEvent[V]; org.jgrapht.event.VertexTraversalEvent<V>; org.jgrapht.traverse.CrossComponentIterator; next[]; V; null; this>
<org.jgrapht.traverse.CrossComponentIterator; addUnseenChildrenOf[V]; void; org.jgrapht.traverse.CrossComponentIterator; next[]; V; null; this>
<java.util.Map; get[java.lang.Object]; D; org.jgrapht.traverse.CrossComponentIterator; getSeenData[V]; D; null; seen>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.traverse.CrossComponentIterator; isSeenVertex[java.lang.Object]; boolean; null; seen>
<java.util.Map; put[V, D]; D; org.jgrapht.traverse.CrossComponentIterator; putSeenData[V, D]; D; null; seen>
<org.jgrapht.traverse.AbstractGraphIterator; fireVertexFinished[org.jgrapht.event.VertexTraversalEvent<V>]; void; org.jgrapht.traverse.CrossComponentIterator; finishVertex[V]; void; null; this>
<org.jgrapht.traverse.CrossComponentIterator; createVertexTraversalEvent[V]; org.jgrapht.event.VertexTraversalEvent<V>; org.jgrapht.traverse.CrossComponentIterator; finishVertex[V]; void; null; this>
<org.jgrapht.traverse.CrossComponentIterator$Specifics; edgesOf[V]; java.util.Set<? extends E>; org.jgrapht.traverse.CrossComponentIterator; addUnseenChildrenOf[V]; void; null; specifics>
<org.jgrapht.traverse.AbstractGraphIterator; fireEdgeTraversed[org.jgrapht.event.EdgeTraversalEvent<V,E>]; void; org.jgrapht.traverse.CrossComponentIterator; addUnseenChildrenOf[V]; void; null; this>
<org.jgrapht.traverse.CrossComponentIterator; createEdgeTraversalEvent[E]; org.jgrapht.event.EdgeTraversalEvent<V,E>; org.jgrapht.traverse.CrossComponentIterator; addUnseenChildrenOf[V]; void; null; this>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.traverse.CrossComponentIterator; addUnseenChildrenOf[V]; void; null; Graphs>
<org.jgrapht.traverse.CrossComponentIterator; isSeenVertex[java.lang.Object]; boolean; org.jgrapht.traverse.CrossComponentIterator; addUnseenChildrenOf[V]; void; null; this>
<org.jgrapht.traverse.CrossComponentIterator; encounterVertexAgain[V, E]; void; org.jgrapht.traverse.CrossComponentIterator; addUnseenChildrenOf[V]; void; null; this>
<org.jgrapht.traverse.CrossComponentIterator; encounterVertex[V, E]; void; org.jgrapht.traverse.CrossComponentIterator; addUnseenChildrenOf[V]; void; null; this>
<org.jgrapht.traverse.AbstractGraphIterator; isReuseEvents[]; boolean; org.jgrapht.traverse.CrossComponentIterator; createEdgeTraversalEvent[E]; org.jgrapht.event.EdgeTraversalEvent<V,E>; null; this>
<org.jgrapht.traverse.CrossComponentIterator$FlyweightEdgeEvent; setEdge[E]; void; org.jgrapht.traverse.CrossComponentIterator; createEdgeTraversalEvent[E]; org.jgrapht.event.EdgeTraversalEvent<V,E>; null; reusableEdgeEvent>
<org.jgrapht.traverse.AbstractGraphIterator; isReuseEvents[]; boolean; org.jgrapht.traverse.CrossComponentIterator; createVertexTraversalEvent[V]; org.jgrapht.event.VertexTraversalEvent<V>; null; this>
<org.jgrapht.traverse.CrossComponentIterator$FlyweightVertexEvent; setVertex[V]; void; org.jgrapht.traverse.CrossComponentIterator; createVertexTraversalEvent[V]; org.jgrapht.event.VertexTraversalEvent<V>; null; reusableVertexEvent>
<org.jgrapht.traverse.CrossComponentIterator; encounterVertex[V, E]; void; org.jgrapht.traverse.CrossComponentIterator; encounterStartVertex[]; void; null; this>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[VV]; java.util.Set<EE>; org.jgrapht.traverse.CrossComponentIterator.DirectedSpecifics; edgesOf[VV]; java.util.Set<? extends EE>; null; graph>
<org.jgrapht.Graph; edgesOf[VV]; java.util.Set<EE>; org.jgrapht.traverse.CrossComponentIterator.UndirectedSpecifics; edgesOf[VV]; java.util.Set<EE>; null; graph>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.BreadthFirstIterator; isConnectedComponentExhausted[]; boolean; null; queue>
<org.jgrapht.traverse.CrossComponentIterator; putSeenData[V, java.lang.Object]; java.lang.Object; org.jgrapht.traverse.BreadthFirstIterator; encounterVertex[V, E]; void; null; this>
<java.util.Deque; add[V]; boolean; org.jgrapht.traverse.BreadthFirstIterator; encounterVertex[V, E]; void; null; queue>
<java.util.Deque; removeFirst[]; V; org.jgrapht.traverse.BreadthFirstIterator; provideNextVertex[]; V; null; queue>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; sourceVertex>
<java.util.Set; size[]; int; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; forwardList>
<java.util.Set; size[]; int; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; reverseList>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; list>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; list>
<org.jgrapht.graph.GraphDelegator; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.AsUndirectedGraph; toString[]; java.lang.String; null; this>
<org.jgrapht.graph.GraphDelegator; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.AsUndirectedGraph; toString[]; java.lang.String; null; this>
<org.jgrapht.graph.MaskFunctor; isVertexMasked[V]; boolean; org.jgrapht.graph.MaskVertexSet; contains[java.lang.Object]; boolean; null; this.mask>
<org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<V>]; V; org.jgrapht.graph.MaskVertexSet; contains[java.lang.Object]; boolean; null; TypeUtil>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskVertexSet; contains[java.lang.Object]; boolean; null; this.vertexSet>
<org.jgrapht.graph.MaskVertexSet; iterator[]; java.util.Iterator<V>; org.jgrapht.graph.MaskVertexSet; size[]; int; null; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.MaskVertexSet; size[]; int; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.graph.MaskVertexSet; size[]; int; null; iter>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.graph.MaskVertexSet.MaskVertexSetNextElementFunctor; MaskVertexSetNextElementFunctor[]; void; null; MaskVertexSet.this.vertexSet>
<java.util.Iterator; next[]; V; org.jgrapht.graph.MaskVertexSet.MaskVertexSetNextElementFunctor; nextElement[]; V; null; this.iter>
<org.jgrapht.graph.MaskFunctor; isVertexMasked[V]; boolean; org.jgrapht.graph.MaskVertexSet.MaskVertexSetNextElementFunctor; nextElement[]; V; null; MaskVertexSet.this.mask>
<java.util.Iterator; next[]; V; org.jgrapht.graph.MaskVertexSet.MaskVertexSetNextElementFunctor; nextElement[]; V; null; this.iter>
<org.jgrapht.ListenableGraph; addGraphListener[org.jgrapht.event.GraphListener<V,E>]; void; org.jgrapht.graph.Subgraph; Subgraph[G, java.util.Set<V>, java.util.Set<E>]; void; null; ((ListenableGraph<V,E>)base)>
<org.jgrapht.graph.Subgraph; addVerticesUsingFilter[java.util.Set<V>, java.util.Set<V>]; void; org.jgrapht.graph.Subgraph; Subgraph[G, java.util.Set<V>, java.util.Set<E>]; void; null; this>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.Subgraph; Subgraph[G, java.util.Set<V>, java.util.Set<E>]; void; null; base>
<org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; org.jgrapht.graph.Subgraph; Subgraph[G, java.util.Set<V>, java.util.Set<E>]; void; null; this>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.Subgraph; Subgraph[G, java.util.Set<V>, java.util.Set<E>]; void; null; base>
<org.jgrapht.graph.Subgraph; containsVertex[V]; boolean; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.graph.Subgraph; containsVertex[V]; boolean; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.Graph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; base>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; baseEdges>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; iter>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; edgeSet>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; edges>
<org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.Subgraph; getEdge[V, V]; E; null; this>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.graph.Subgraph; getEdge[V, V]; E; null; edges>
<java.util.Iterator; next[]; E; org.jgrapht.graph.Subgraph; getEdge[V, V]; E; null; edges.iterator()>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.Subgraph; getEdge[V, V]; E; next[]; edges>
<org.jgrapht.Graph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; org.jgrapht.graph.Subgraph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; null; base>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; this>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; base>
<org.jgrapht.Graph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; base>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; edges>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; iter>
<org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; this>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; edgeSet>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; null; base>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; null; base>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; null; base>
<org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; null; this>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; null; edgeSet>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.Subgraph; addVertex[V]; boolean; null; base>
<org.jgrapht.graph.Subgraph; containsVertex[V]; boolean; org.jgrapht.graph.Subgraph; addVertex[V]; boolean; null; this>
<java.util.Set; add[V]; boolean; org.jgrapht.graph.Subgraph; addVertex[V]; boolean; null; vertexSet>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; null; edgeSet>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; containsVertex[V]; boolean; null; vertexSet>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends E>]; java.util.Set<E>; org.jgrapht.graph.Subgraph; edgeSet[]; java.util.Set<E>; null; Collections>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.Subgraph; edgesOf[V]; java.util.Set<E>; null; this>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.Subgraph; edgesOf[V]; java.util.Set<E>; null; base>
<org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; org.jgrapht.graph.Subgraph; edgesOf[V]; java.util.Set<E>; null; this>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.Subgraph; edgesOf[V]; java.util.Set<E>; null; edges>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; removeEdge[E]; boolean; null; edgeSet>
<org.jgrapht.graph.Subgraph; getEdge[V, V]; E; org.jgrapht.graph.Subgraph; removeEdge[V, V]; E; null; this>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; removeEdge[V, V]; E; null; edgeSet>
<org.jgrapht.graph.Subgraph; containsVertex[V]; boolean; org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; null; this>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; null; base>
<org.jgrapht.graph.AbstractGraph; removeAllEdges[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; null; this>
<org.jgrapht.graph.Subgraph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; null; this>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; null; vertexSet>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends V>]; java.util.Set<V>; org.jgrapht.graph.Subgraph; vertexSet[]; java.util.Set<V>; null; Collections>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.Subgraph; getEdgeSource[E]; V; null; base>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.Subgraph; getEdgeTarget[E]; V; null; base>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; edgeSet>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; iter>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; base>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; base>
<org.jgrapht.graph.Subgraph; containsVertex[V]; boolean; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; this>
<org.jgrapht.graph.Subgraph; containsVertex[V]; boolean; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; this>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; filter>
<org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; this>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.graph.Subgraph; addVerticesUsingFilter[java.util.Set<V>, java.util.Set<V>]; void; null; vertexSet>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.Subgraph; addVerticesUsingFilter[java.util.Set<V>, java.util.Set<V>]; void; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.graph.Subgraph; addVerticesUsingFilter[java.util.Set<V>, java.util.Set<V>]; void; null; iter>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; addVerticesUsingFilter[java.util.Set<V>, java.util.Set<V>]; void; null; filter>
<org.jgrapht.graph.Subgraph; addVertex[V]; boolean; org.jgrapht.graph.Subgraph; addVerticesUsingFilter[java.util.Set<V>, java.util.Set<V>]; void; null; this>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.graph.Subgraph; getEdgeWeight[E]; double; null; base>
<org.jgrapht.WeightedGraph; setEdgeWeight[E, double]; void; org.jgrapht.graph.Subgraph; setEdgeWeight[E, double]; void; null; ((WeightedGraph<V,E>)base)>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; org.jgrapht.graph.Subgraph.BaseGraphListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; org.jgrapht.graph.Subgraph.BaseGraphListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.Subgraph.BaseGraphListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; base>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.Subgraph.BaseGraphListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; base>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; org.jgrapht.graph.Subgraph.BaseGraphListener; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<org.jgrapht.graph.Subgraph; removeEdge[E]; boolean; org.jgrapht.graph.Subgraph.BaseGraphListener; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.event.GraphVertexChangeEvent; getVertex[]; V; org.jgrapht.graph.Subgraph.BaseGraphListener; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; e>
<org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; org.jgrapht.graph.Subgraph.BaseGraphListener; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; this>
<org.jgrapht.graph.ParanoidGraph; verifyAdd[java.util.Set<E>, E]; void; org.jgrapht.graph.ParanoidGraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.graph.GraphDelegator; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.ParanoidGraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.graph.ParanoidGraph; verifyAdd[java.util.Set<V>, V]; void; org.jgrapht.graph.ParanoidGraph; addVertex[V]; boolean; null; this>
<org.jgrapht.graph.GraphDelegator; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.ParanoidGraph; addVertex[V]; boolean; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.ParanoidGraph; verifyAdd[java.util.Set<T>, T]; void; null; o>
<java.lang.Object; hashCode[]; int; org.jgrapht.graph.ParanoidGraph; verifyAdd[java.util.Set<T>, T]; void; null; o>
<java.lang.Object; hashCode[]; int; org.jgrapht.graph.ParanoidGraph; verifyAdd[java.util.Set<T>, T]; void; null; t>
<java.lang.Object; hashCode[]; int; org.jgrapht.graph.ParanoidGraph; verifyAdd[java.util.Set<T>, T]; void; null; o>
<java.lang.Object; hashCode[]; int; org.jgrapht.graph.ParanoidGraph; verifyAdd[java.util.Set<T>, T]; void; null; t>
<org.jgrapht.Graph; getEdge[V, V]; E; org.jgrapht.graph.AbstractGraph; containsEdge[V, V]; boolean; null; this>
<org.jgrapht.Graph; removeEdge[E]; boolean; org.jgrapht.graph.AbstractGraph; removeAllEdges[java.util.Collection<? extends E>]; boolean; null; this>
<org.jgrapht.Graph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.AbstractGraph; removeAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.graph.AbstractGraph; removeAllEdges[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.AbstractGraph; removeAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.Graph; removeVertex[V]; boolean; org.jgrapht.graph.AbstractGraph; removeAllVertices[java.util.Collection<? extends V>]; boolean; null; this>
<org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; org.jgrapht.graph.AbstractGraph; toString[]; java.lang.String; null; this>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.AbstractGraph; toString[]; java.lang.String; null; this>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.AbstractGraph; toString[]; java.lang.String; null; this>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; null; this>
<org.jgrapht.Graph; removeEdge[E]; boolean; org.jgrapht.graph.AbstractGraph; removeAllEdges[E[]]; boolean; null; this>
<java.lang.Object; getClass[]; java.lang.Class<? extends java.lang.Object>; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; e>
<java.lang.Object; getClass[]; java.lang.Class<? extends java.lang.Object>; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; e>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; e>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<java.lang.StringBuffer; append[java.lang.Object]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; this>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<java.lang.StringBuffer; append[java.lang.Object]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; this>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<java.lang.StringBuffer; append[java.lang.String]; java.lang.StringBuffer; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<java.util.List; add[java.lang.String]; boolean; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; renderedEdges>
<java.lang.StringBuffer; toString[]; java.lang.String; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<java.lang.StringBuffer; setLength[int]; void; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; sb>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.MaskSubgraph; MaskSubgraph[org.jgrapht.Graph<V,E>, org.jgrapht.graph.MaskFunctor<V,E>]; void; null; base>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; MaskSubgraph[org.jgrapht.Graph<V,E>, org.jgrapht.graph.MaskFunctor<V,E>]; void; null; base>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskSubgraph; containsEdge[E]; boolean; null; edgeSet()>
<org.jgrapht.graph.MaskSubgraph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; containsEdge[E]; boolean; contains[java.lang.Object]; this>
<org.jgrapht.graph.MaskFunctor; isVertexMasked[V]; boolean; org.jgrapht.graph.MaskSubgraph; containsVertex[V]; boolean; null; this.mask>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.MaskSubgraph; containsVertex[V]; boolean; null; this.base>
<java.util.Set; size[]; int; org.jgrapht.graph.MaskSubgraph; degreeOf[V]; int; null; edgesOf(vertex)>
<org.jgrapht.graph.MaskSubgraph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; degreeOf[V]; int; size[]; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.MaskSubgraph; edgesOf[V]; java.util.Set<E>; null; this>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; edgesOf[V]; java.util.Set<E>; null; this.base>
<org.jgrapht.graph.MaskSubgraph; containsVertex[V]; boolean; org.jgrapht.graph.MaskSubgraph; getAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.graph.MaskSubgraph; containsVertex[V]; boolean; org.jgrapht.graph.MaskSubgraph; getAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.Graph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; getAllEdges[V, V]; java.util.Set<E>; null; this.base>
<org.jgrapht.graph.MaskSubgraph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; getEdge[V, V]; E; null; this>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.graph.MaskSubgraph; getEdge[V, V]; E; null; edges>
<java.util.Iterator; next[]; E; org.jgrapht.graph.MaskSubgraph; getEdge[V, V]; E; null; edges.iterator()>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.MaskSubgraph; getEdge[V, V]; E; next[]; edges>
<org.jgrapht.Graph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; org.jgrapht.graph.MaskSubgraph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; null; this.base>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskSubgraph; getEdgeSource[E]; V; null; edgeSet()>
<org.jgrapht.graph.MaskSubgraph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; getEdgeSource[E]; V; contains[java.lang.Object]; this>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.MaskSubgraph; getEdgeSource[E]; V; null; this.base>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskSubgraph; getEdgeTarget[E]; V; null; edgeSet()>
<org.jgrapht.graph.MaskSubgraph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; getEdgeTarget[E]; V; contains[java.lang.Object]; this>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.MaskSubgraph; getEdgeTarget[E]; V; null; this.base>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskSubgraph; getEdgeWeight[E]; double; null; edgeSet()>
<org.jgrapht.graph.MaskSubgraph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; getEdgeWeight[E]; double; contains[java.lang.Object]; this>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.graph.MaskSubgraph; getEdgeWeight[E]; double; null; this.base>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.MaskSubgraph; incomingEdgesOf[V]; java.util.Set<E>; null; this>
<org.jgrapht.DirectedGraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; incomingEdgesOf[V]; java.util.Set<E>; null; ((DirectedGraph<V,E>)this.base)>
<java.util.Set; size[]; int; org.jgrapht.graph.MaskSubgraph; inDegreeOf[V]; int; null; incomingEdgesOf(vertex)>
<org.jgrapht.graph.MaskSubgraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; inDegreeOf[V]; int; size[]; this>
<java.util.Set; size[]; int; org.jgrapht.graph.MaskSubgraph; outDegreeOf[V]; int; null; outgoingEdgesOf(vertex)>
<org.jgrapht.graph.MaskSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; outDegreeOf[V]; int; size[]; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.MaskSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; null; this>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.MaskSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; null; ((DirectedGraph<V,E>)this.base)>
<org.jgrapht.graph.DefaultGraphMapping; getVertexCorrespondence[V, boolean]; V; org.jgrapht.graph.DefaultGraphMapping; getEdgeCorrespondence[E, boolean]; E; null; this>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.DefaultGraphMapping; getEdgeCorrespondence[E, boolean]; E; null; sourceGraph>
<org.jgrapht.graph.DefaultGraphMapping; getVertexCorrespondence[V, boolean]; V; org.jgrapht.graph.DefaultGraphMapping; getEdgeCorrespondence[E, boolean]; E; null; this>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.DefaultGraphMapping; getEdgeCorrespondence[E, boolean]; E; null; sourceGraph>
<org.jgrapht.Graph; getEdge[V, V]; E; org.jgrapht.graph.DefaultGraphMapping; getEdgeCorrespondence[E, boolean]; E; null; targetGraph>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.graph.DefaultGraphMapping; getVertexCorrespondence[V, boolean]; V; getEdge[V, V]; graphMapping>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskEdgeSet; contains[java.lang.Object]; boolean; null; this.edgeSet>
<org.jgrapht.graph.MaskFunctor; isEdgeMasked[E]; boolean; org.jgrapht.graph.MaskEdgeSet; contains[java.lang.Object]; boolean; null; this.mask>
<org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<E>]; E; org.jgrapht.graph.MaskEdgeSet; contains[java.lang.Object]; boolean; null; TypeUtil>
<org.jgrapht.graph.MaskEdgeSet; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.MaskEdgeSet; size[]; int; null; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.MaskEdgeSet; size[]; int; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.graph.MaskEdgeSet; size[]; int; null; iter>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; MaskEdgeSetNextElementFunctor[]; void; null; MaskEdgeSet.this.edgeSet>
<java.util.Iterator; next[]; E; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; nextElement[]; E; null; this.iter>
<org.jgrapht.graph.MaskEdgeSet$MaskEdgeSetNextElementFunctor; isMasked[E]; boolean; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; nextElement[]; E; null; this>
<java.util.Iterator; next[]; E; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; nextElement[]; E; null; this.iter>
<org.jgrapht.graph.MaskFunctor; isEdgeMasked[E]; boolean; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; isMasked[E]; boolean; null; MaskEdgeSet.this.mask>
<org.jgrapht.graph.MaskFunctor; isVertexMasked[V]; boolean; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; isMasked[E]; boolean; null; MaskEdgeSet.this.mask>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; isMasked[E]; boolean; null; MaskEdgeSet.this.graph>
<org.jgrapht.graph.MaskFunctor; isVertexMasked[V]; boolean; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; isMasked[E]; boolean; null; MaskEdgeSet.this.mask>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; isMasked[E]; boolean; null; MaskEdgeSet.this.graph>
<org.jgrapht.graph.AbstractBaseGraph; createSpecifics[]; org.jgrapht.graph.AbstractBaseGraph<V,E>.Specifics; org.jgrapht.graph.AbstractBaseGraph; AbstractBaseGraph[org.jgrapht.EdgeFactory<V,E>, boolean, boolean]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph; getAllEdges[V, V]; java.util.Set<E>; null; specifics>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; getEdge[V, V]; E; org.jgrapht.graph.AbstractBaseGraph; getEdge[V, V]; E; null; specifics>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractGraph; containsEdge[V, V]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; sourceVertex>
<org.jgrapht.EdgeFactory; createEdge[V, V]; E; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; edgeFactory>
<org.jgrapht.graph.AbstractBaseGraph; containsEdge[E]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractBaseGraph; createIntrusiveEdge[E, V, V]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; this>
<java.util.Map; put[E, org.jgrapht.graph.IntrusiveEdge]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; edgeMap>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; addEdgeToTouchingVertices[E]; void; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; specifics>
<org.jgrapht.graph.AbstractBaseGraph; containsEdge[E]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.graph.AbstractGraph; containsEdge[V, V]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; sourceVertex>
<org.jgrapht.graph.AbstractBaseGraph; createIntrusiveEdge[E, V, V]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; this>
<java.util.Map; put[E, org.jgrapht.graph.IntrusiveEdge]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; edgeMap>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; addEdgeToTouchingVertices[E]; void; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; specifics>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph; addVertex[V]; boolean; null; this>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; addVertex[V]; void; org.jgrapht.graph.AbstractBaseGraph; addVertex[V]; boolean; null; specifics>
<org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<V>]; V; org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; null; TypeUtil>
<org.jgrapht.graph.AbstractBaseGraph; getIntrusiveEdge[E]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; null; this>
<org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<V>]; V; org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; null; TypeUtil>
<org.jgrapht.graph.AbstractBaseGraph; getIntrusiveEdge[E]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; null; this>
<java.util.Map; get[java.lang.Object]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; getIntrusiveEdge[E]; org.jgrapht.graph.IntrusiveEdge; null; edgeMap>
<org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<org.jgrapht.graph.AbstractBaseGraph<V,E>>]; org.jgrapht.graph.AbstractBaseGraph<V,E>; org.jgrapht.graph.AbstractBaseGraph; clone[]; java.lang.Object; null; TypeUtil>
<org.jgrapht.graph.AbstractBaseGraph; createSpecifics[]; org.jgrapht.graph.AbstractBaseGraph<V,E>.Specifics; org.jgrapht.graph.AbstractBaseGraph; clone[]; java.lang.Object; null; newGraph>
<org.jgrapht.Graphs; addGraph[org.jgrapht.Graph<? super V,? super E>, org.jgrapht.Graph<V,E>]; boolean; org.jgrapht.graph.AbstractBaseGraph; clone[]; java.lang.Object; null; Graphs>
<java.lang.Throwable; printStackTrace[]; void; org.jgrapht.graph.AbstractBaseGraph; clone[]; java.lang.Object; null; e>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; containsEdge[E]; boolean; null; edgeMap>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; null; specifics.getVertexSet()>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; getVertexSet[]; java.util.Set<V>; org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; contains[java.lang.Object]; specifics>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; degreeOf[V]; int; org.jgrapht.graph.AbstractBaseGraph; degreeOf[V]; int; null; specifics>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends E>]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph; edgeSet[]; java.util.Set<E>; null; Collections>
<java.util.Map; keySet[]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph; edgeSet[]; java.util.Set<E>; null; edgeMap>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph; edgesOf[V]; java.util.Set<E>; null; specifics>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; inDegreeOf[V]; int; org.jgrapht.graph.AbstractBaseGraph; inDegreeOf[V]; int; null; specifics>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph; incomingEdgesOf[V]; java.util.Set<E>; null; specifics>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; outDegreeOf[V]; int; org.jgrapht.graph.AbstractBaseGraph; outDegreeOf[V]; int; null; specifics>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph; outgoingEdgesOf[V]; java.util.Set<E>; null; specifics>
<org.jgrapht.graph.AbstractBaseGraph; getEdge[V, V]; E; org.jgrapht.graph.AbstractBaseGraph; removeEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; removeEdgeFromTouchingVertices[E]; void; org.jgrapht.graph.AbstractBaseGraph; removeEdge[V, V]; E; null; specifics>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; removeEdge[V, V]; E; null; edgeMap>
<org.jgrapht.graph.AbstractBaseGraph; containsEdge[E]; boolean; org.jgrapht.graph.AbstractBaseGraph; removeEdge[E]; boolean; null; this>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; removeEdgeFromTouchingVertices[E]; void; org.jgrapht.graph.AbstractBaseGraph; removeEdge[E]; boolean; null; specifics>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; removeEdge[E]; boolean; null; edgeMap>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph; removeVertex[V]; boolean; null; this>
<org.jgrapht.graph.AbstractBaseGraph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph; removeVertex[V]; boolean; null; this>
<org.jgrapht.graph.AbstractGraph; removeAllEdges[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.AbstractBaseGraph; removeVertex[V]; boolean; null; this>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; removeVertex[V]; boolean; null; specifics.getVertexSet()>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; getVertexSet[]; java.util.Set<V>; org.jgrapht.graph.AbstractBaseGraph; removeVertex[V]; boolean; remove[java.lang.Object]; specifics>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends V>]; java.util.Set<V>; org.jgrapht.graph.AbstractBaseGraph; vertexSet[]; java.util.Set<V>; null; Collections>
<org.jgrapht.graph.AbstractBaseGraph$Specifics; getVertexSet[]; java.util.Set<V>; org.jgrapht.graph.AbstractBaseGraph; vertexSet[]; java.util.Set<V>; null; specifics>
<java.lang.Object; getClass[]; java.lang.Class<? extends java.lang.Object>; org.jgrapht.graph.AbstractBaseGraph; setEdgeWeight[E, double]; void; null; e>
<org.jgrapht.graph.EdgeSetFactory; createEdgeSet[VV]; java.util.Set<EE>; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; DirectedEdgeContainer[org.jgrapht.graph.EdgeSetFactory<VV,EE>, VV]; void; null; edgeSetFactory>
<org.jgrapht.graph.EdgeSetFactory; createEdgeSet[VV]; java.util.Set<EE>; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; DirectedEdgeContainer[org.jgrapht.graph.EdgeSetFactory<VV,EE>, VV]; void; null; edgeSetFactory>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends EE>]; java.util.Set<EE>; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; getUnmodifiableIncomingEdges[]; java.util.Set<EE>; null; Collections>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends EE>]; java.util.Set<EE>; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; getUnmodifiableOutgoingEdges[]; java.util.Set<EE>; null; Collections>
<java.util.Set; add[EE]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; addIncomingEdge[EE]; void; null; incoming>
<java.util.Set; add[EE]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; addOutgoingEdge[EE]; void; null; outgoing>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; removeIncomingEdge[EE]; void; null; incoming>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; removeOutgoingEdge[EE]; void; null; outgoing>
<java.util.Map; put[V, org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; addVertex[V]; void; null; vertexMapDirected>
<java.util.Map; keySet[]; java.util.Set<V>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getVertexSet[]; java.util.Set<V>; null; vertexMapDirected>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; ec.outgoing>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; iter>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; getEdgeTarget(e)>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; equals[java.lang.Object]; this>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; edges>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; null; this>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; null; ec.outgoing>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; null; iter>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; null; getEdgeTarget(e)>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; equals[java.lang.Object]; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedEdgeContainer; addOutgoingEdge[E]; void; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; getEdgeContainer(source)>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; addEdgeToTouchingVertices[E]; void; addOutgoingEdge[E]; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedEdgeContainer; addIncomingEdge[E]; void; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; getEdgeContainer(target)>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; addEdgeToTouchingVertices[E]; void; addIncomingEdge[E]; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; this>
<java.util.ArrayList; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; inAndOut>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; this>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; inAndOut>
<java.util.ArrayList; get[int]; E; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; inAndOut>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; loops>
<java.util.ArrayList; remove[int]; E; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; inAndOut>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; loops>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends E>]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; Collections>
<java.util.Set; size[]; int; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; inDegreeOf[V]; int; null; getEdgeContainer(vertex).incoming>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; inDegreeOf[V]; int; size[]; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedEdgeContainer; getUnmodifiableIncomingEdges[]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; incomingEdgesOf[V]; java.util.Set<E>; null; getEdgeContainer(vertex)>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; incomingEdgesOf[V]; java.util.Set<E>; getUnmodifiableIncomingEdges[]; this>
<java.util.Set; size[]; int; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; outDegreeOf[V]; int; null; getEdgeContainer(vertex).outgoing>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; outDegreeOf[V]; int; size[]; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedEdgeContainer; getUnmodifiableOutgoingEdges[]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; outgoingEdgesOf[V]; java.util.Set<E>; null; getEdgeContainer(vertex)>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; outgoingEdgesOf[V]; java.util.Set<E>; getUnmodifiableOutgoingEdges[]; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedEdgeContainer; removeOutgoingEdge[E]; void; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; getEdgeContainer(source)>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; removeOutgoingEdge[E]; this>
<org.jgrapht.graph.AbstractBaseGraph$DirectedEdgeContainer; removeIncomingEdge[E]; void; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; getEdgeContainer(target)>
<org.jgrapht.graph.AbstractBaseGraph$DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; removeIncomingEdge[E]; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; null; this>
<java.util.Map; get[java.lang.Object]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; null; vertexMapDirected>
<java.util.Map; put[V, org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; null; vertexMapDirected>
<org.jgrapht.graph.EdgeSetFactory; createEdgeSet[VV]; java.util.Set<EE>; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer; UndirectedEdgeContainer[org.jgrapht.graph.EdgeSetFactory<VV,EE>, VV]; void; null; edgeSetFactory>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends EE>]; java.util.Set<EE>; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer; getUnmodifiableVertexEdges[]; java.util.Set<EE>; null; Collections>
<java.util.Set; add[EE]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer; addEdge[EE]; void; null; vertexEdges>
<java.util.Set; size[]; int; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer; edgeCount[]; int; null; vertexEdges>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer; removeEdge[EE]; void; null; vertexEdges>
<java.util.Map; put[V, org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addVertex[V]; void; null; vertexMapUndirected>
<java.util.Map; keySet[]; java.util.Set<V>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getVertexSet[]; java.util.Set<V>; null; vertexMapUndirected>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; getEdgeContainer(sourceVertex).vertexEdges>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; iterator[]; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; iter>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; sourceVertex>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; targetVertex>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; sourceVertex>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; targetVertex>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; this>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; edges>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; this>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; getEdgeContainer(sourceVertex).vertexEdges>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; iterator[]; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; iter>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; sourceVertex>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; targetVertex>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; sourceVertex>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; targetVertex>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedEdgeContainer; addEdge[E]; void; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; getEdgeContainer(source)>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addEdgeToTouchingVertices[E]; void; addEdge[E]; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; source>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedEdgeContainer; addEdge[E]; void; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addEdgeToTouchingVertices[E]; void; null; getEdgeContainer(target)>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addEdgeToTouchingVertices[E]; void; addEdge[E]; this>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; degreeOf[V]; int; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; degreeOf[V]; int; null; getEdgeSource(e)>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; degreeOf[V]; int; equals[java.lang.Object]; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; degreeOf[V]; int; null; this>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedEdgeContainer; edgeCount[]; int; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; degreeOf[V]; int; null; getEdgeContainer(vertex)>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; degreeOf[V]; int; edgeCount[]; this>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedEdgeContainer; getUnmodifiableVertexEdges[]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; getEdgeContainer(vertex)>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; edgesOf[V]; java.util.Set<E>; getUnmodifiableVertexEdges[]; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeSource[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedEdgeContainer; removeEdge[E]; void; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; getEdgeContainer(source)>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; removeEdge[E]; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; source>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedEdgeContainer; removeEdge[E]; void; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; null; getEdgeContainer(target)>
<org.jgrapht.graph.AbstractBaseGraph$UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; removeEdgeFromTouchingVertices[E]; void; removeEdge[E]; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; null; this>
<java.util.Map; get[java.lang.Object]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; null; vertexMapUndirected>
<java.util.Map; put[V, org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; null; vertexMapUndirected>
<java.lang.Class; newInstance[]; ; org.jgrapht.graph.ClassBasedVertexFactory; createVertex[]; V; null; this.vertexClass>
<java.util.Map; put[E, java.lang.Double]; java.lang.Double; org.jgrapht.graph.AsWeightedGraph; setEdgeWeight[E, double]; void; null; weightMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.graph.AsWeightedGraph; getEdgeWeight[E]; double; null; weightMap>
<java.util.Map; get[java.lang.Object]; java.lang.Double; org.jgrapht.graph.AsWeightedGraph; getEdgeWeight[E]; double; null; weightMap>
<org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedGraphUnion; inDegreeOf[V]; int; null; this>
<java.util.Set; size[]; int; org.jgrapht.graph.DirectedGraphUnion; inDegreeOf[V]; int; null; res>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; getG1()>
<org.jgrapht.graph.GraphUnion; getG1[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; containsVertex[V]; this>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; res>
<org.jgrapht.DirectedGraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; getG1()>
<org.jgrapht.graph.GraphUnion; getG1[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; incomingEdgesOf[V]; this>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; getG2()>
<org.jgrapht.graph.GraphUnion; getG2[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; containsVertex[V]; this>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; res>
<org.jgrapht.DirectedGraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; getG2()>
<org.jgrapht.graph.GraphUnion; getG2[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; incomingEdgesOf[V]; this>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends E>]; java.util.Set<E>; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; Collections>
<org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedGraphUnion; outDegreeOf[V]; int; null; this>
<java.util.Set; size[]; int; org.jgrapht.graph.DirectedGraphUnion; outDegreeOf[V]; int; null; res>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; getG1()>
<org.jgrapht.graph.GraphUnion; getG1[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; containsVertex[V]; this>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; res>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; getG1()>
<org.jgrapht.graph.GraphUnion; getG1[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; outgoingEdgesOf[V]; this>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; getG2()>
<org.jgrapht.graph.GraphUnion; getG2[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; containsVertex[V]; this>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; res>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; getG2()>
<org.jgrapht.graph.GraphUnion; getG2[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; outgoingEdgesOf[V]; this>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends E>]; java.util.Set<E>; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; Collections>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.DirectedSubgraph; inDegreeOf[V]; int; null; this>
<org.jgrapht.DirectedGraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedSubgraph; inDegreeOf[V]; int; null; getBase()>
<org.jgrapht.graph.Subgraph; getBase[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedSubgraph; inDegreeOf[V]; int; incomingEdgesOf[V]; this>
<org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; org.jgrapht.graph.DirectedSubgraph; inDegreeOf[V]; int; null; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.DirectedSubgraph; incomingEdgesOf[V]; java.util.Set<E>; null; this>
<org.jgrapht.DirectedGraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedSubgraph; incomingEdgesOf[V]; java.util.Set<E>; null; getBase()>
<org.jgrapht.graph.Subgraph; getBase[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedSubgraph; incomingEdgesOf[V]; java.util.Set<E>; incomingEdgesOf[V]; this>
<org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; org.jgrapht.graph.DirectedSubgraph; incomingEdgesOf[V]; java.util.Set<E>; null; this>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.DirectedSubgraph; incomingEdgesOf[V]; java.util.Set<E>; null; edges>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.DirectedSubgraph; outDegreeOf[V]; int; null; this>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedSubgraph; outDegreeOf[V]; int; null; getBase()>
<org.jgrapht.graph.Subgraph; getBase[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedSubgraph; outDegreeOf[V]; int; outgoingEdgesOf[V]; this>
<org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; org.jgrapht.graph.DirectedSubgraph; outDegreeOf[V]; int; null; this>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.DirectedSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; null; this>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DirectedSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; null; getBase()>
<org.jgrapht.graph.Subgraph; getBase[]; org.jgrapht.DirectedGraph<V,E>; org.jgrapht.graph.DirectedSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; outgoingEdgesOf[V]; this>
<org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; org.jgrapht.graph.DirectedSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; null; this>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.DirectedSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; null; edges>
<org.jgrapht.Graph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.GraphDelegator; getAllEdges[V, V]; java.util.Set<E>; null; delegate>
<org.jgrapht.Graph; getEdge[V, V]; E; org.jgrapht.graph.GraphDelegator; getEdge[V, V]; E; null; delegate>
<org.jgrapht.Graph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; org.jgrapht.graph.GraphDelegator; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; null; delegate>
<org.jgrapht.Graph; addEdge[V, V]; E; org.jgrapht.graph.GraphDelegator; addEdge[V, V]; E; null; delegate>
<org.jgrapht.Graph; addEdge[V, V, E]; boolean; org.jgrapht.graph.GraphDelegator; addEdge[V, V, E]; boolean; null; delegate>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.graph.GraphDelegator; addVertex[V]; boolean; null; delegate>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphDelegator; containsEdge[E]; boolean; null; delegate>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphDelegator; containsVertex[V]; boolean; null; delegate>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.graph.GraphDelegator; degreeOf[V]; int; null; ((UndirectedGraph<V,E>)delegate)>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.GraphDelegator; edgeSet[]; java.util.Set<E>; null; delegate>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.GraphDelegator; edgesOf[V]; java.util.Set<E>; null; delegate>
<org.jgrapht.DirectedGraph; inDegreeOf[V]; int; org.jgrapht.graph.GraphDelegator; inDegreeOf[V]; int; null; ((DirectedGraph<V,? extends E>)delegate)>
<org.jgrapht.DirectedGraph; incomingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.GraphDelegator; incomingEdgesOf[V]; java.util.Set<E>; null; ((DirectedGraph<V,E>)delegate)>
<org.jgrapht.DirectedGraph; outDegreeOf[V]; int; org.jgrapht.graph.GraphDelegator; outDegreeOf[V]; int; null; ((DirectedGraph<V,? extends E>)delegate)>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.graph.GraphDelegator; outgoingEdgesOf[V]; java.util.Set<E>; null; ((DirectedGraph<V,E>)delegate)>
<org.jgrapht.Graph; removeEdge[E]; boolean; org.jgrapht.graph.GraphDelegator; removeEdge[E]; boolean; null; delegate>
<org.jgrapht.Graph; removeEdge[V, V]; E; org.jgrapht.graph.GraphDelegator; removeEdge[V, V]; E; null; delegate>
<org.jgrapht.Graph; removeVertex[V]; boolean; org.jgrapht.graph.GraphDelegator; removeVertex[V]; boolean; null; delegate>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.graph.GraphDelegator; toString[]; java.lang.String; null; delegate>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.GraphDelegator; vertexSet[]; java.util.Set<V>; null; delegate>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.GraphDelegator; getEdgeSource[E]; V; null; delegate>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.GraphDelegator; getEdgeTarget[E]; V; null; delegate>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.graph.GraphDelegator; getEdgeWeight[E]; double; null; delegate>
<org.jgrapht.WeightedGraph; setEdgeWeight[E, double]; void; org.jgrapht.graph.GraphDelegator; setEdgeWeight[E, double]; void; null; ((WeightedGraph<V,E>)delegate)>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.graph.GraphPathImpl; toString[]; java.lang.String; null; edgeList>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; g1>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; g1>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; res>
<org.jgrapht.Graph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; g1>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; g2>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; g2>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; res>
<org.jgrapht.Graph; getAllEdges[V, V]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; g2>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends E>]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; Collections>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; getEdge[V, V]; E; null; g1>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; getEdge[V, V]; E; null; g1>
<org.jgrapht.Graph; getEdge[V, V]; E; org.jgrapht.graph.GraphUnion; getEdge[V, V]; E; null; g1>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; getEdge[V, V]; E; null; g2>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; getEdge[V, V]; E; null; g2>
<org.jgrapht.Graph; getEdge[V, V]; E; org.jgrapht.graph.GraphUnion; getEdge[V, V]; E; null; g2>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; containsEdge[E]; boolean; null; g1>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; containsEdge[E]; boolean; null; g2>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; containsVertex[V]; boolean; null; g1>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; containsVertex[V]; boolean; null; g2>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; edgeSet[]; java.util.Set<E>; null; res>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; edgeSet[]; java.util.Set<E>; null; g1>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; edgeSet[]; java.util.Set<E>; null; res>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; edgeSet[]; java.util.Set<E>; null; g2>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends E>]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; edgeSet[]; java.util.Set<E>; null; Collections>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; g1>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; res>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; g1>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; g2>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; res>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; g2>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends E>]; java.util.Set<E>; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; Collections>
<java.util.Set; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.graph.GraphUnion; vertexSet[]; java.util.Set<V>; null; res>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.GraphUnion; vertexSet[]; java.util.Set<V>; null; g1>
<java.util.Set; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.graph.GraphUnion; vertexSet[]; java.util.Set<V>; null; res>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.GraphUnion; vertexSet[]; java.util.Set<V>; null; g2>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends V>]; java.util.Set<V>; org.jgrapht.graph.GraphUnion; vertexSet[]; java.util.Set<V>; null; Collections>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; getEdgeSource[E]; V; null; g1>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.GraphUnion; getEdgeSource[E]; V; null; g1>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; getEdgeSource[E]; V; null; g2>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.graph.GraphUnion; getEdgeSource[E]; V; null; g2>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; getEdgeTarget[E]; V; null; g1>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.GraphUnion; getEdgeTarget[E]; V; null; g1>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; getEdgeTarget[E]; V; null; g2>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.graph.GraphUnion; getEdgeTarget[E]; V; null; g2>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; g1>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; g2>
<org.jgrapht.util.WeightCombiner; combine[double, double]; double; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; operator>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; g1>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; g2>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; g1>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; g1>
<org.jgrapht.Graph; containsEdge[E]; boolean; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; g2>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.graph.GraphUnion; getEdgeWeight[E]; double; null; g2>
<org.jgrapht.graph.AbstractGraph; assertVertexExist[V]; boolean; org.jgrapht.graph.UndirectedSubgraph; degreeOf[V]; int; null; this>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.UndirectedSubgraph; degreeOf[V]; int; null; getBase()>
<org.jgrapht.graph.Subgraph; getBase[]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.graph.UndirectedSubgraph; degreeOf[V]; int; edgesOf[V]; this>
<org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; org.jgrapht.graph.UndirectedSubgraph; degreeOf[V]; int; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.graph.UndirectedSubgraph; degreeOf[V]; int; null; getEdgeSource(e)>
<org.jgrapht.graph.Subgraph; getEdgeSource[E]; V; org.jgrapht.graph.UndirectedSubgraph; degreeOf[V]; int; equals[java.lang.Object]; this>
<org.jgrapht.graph.Subgraph; getEdgeTarget[E]; V; org.jgrapht.graph.UndirectedSubgraph; degreeOf[V]; int; null; this>
<org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; org.jgrapht.graph.EdgeReversedGraph; toString[]; java.lang.String; null; this>
<org.jgrapht.graph.GraphDelegator; vertexSet[]; java.util.Set<V>; org.jgrapht.graph.EdgeReversedGraph; toString[]; java.lang.String; null; this>
<org.jgrapht.graph.GraphDelegator; edgeSet[]; java.util.Set<E>; org.jgrapht.graph.EdgeReversedGraph; toString[]; java.lang.String; null; this>
<org.jgrapht.graph.DefaultListenableGraph; fireEdgeAdded[E]; void; org.jgrapht.graph.DefaultListenableGraph; addEdge[V, V]; E; null; this>
<org.jgrapht.graph.DefaultListenableGraph; fireEdgeAdded[E]; void; org.jgrapht.graph.DefaultListenableGraph; addEdge[V, V, E]; boolean; null; this>
<org.jgrapht.graph.DefaultListenableGraph; addToListenerList[java.util.List<org.jgrapht.event.GraphListener<V,E>>, org.jgrapht.event.GraphListener<V,E>]; void; org.jgrapht.graph.DefaultListenableGraph; addGraphListener[org.jgrapht.event.GraphListener<V,E>]; void; null; this>
<org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; org.jgrapht.graph.DefaultListenableGraph; addVertex[V]; boolean; null; this>
<org.jgrapht.graph.DefaultListenableGraph; addToListenerList[java.util.List<org.jgrapht.event.VertexSetListener<V>>, org.jgrapht.event.VertexSetListener<V>]; void; org.jgrapht.graph.DefaultListenableGraph; addVertexSetListener[org.jgrapht.event.VertexSetListener<V>]; void; null; this>
<org.jgrapht.util.TypeUtil; uncheckedCast[java.lang.Object, org.jgrapht.util.TypeUtil<org.jgrapht.graph.DefaultListenableGraph<V,E>>]; org.jgrapht.graph.DefaultListenableGraph<V,E>; org.jgrapht.graph.DefaultListenableGraph; clone[]; java.lang.Object; null; TypeUtil>
<java.lang.Throwable; printStackTrace[]; void; org.jgrapht.graph.DefaultListenableGraph; clone[]; java.lang.Object; null; e>
<org.jgrapht.graph.DefaultListenableGraph; fireEdgeRemoved[E]; void; org.jgrapht.graph.DefaultListenableGraph; removeEdge[V, V]; E; null; this>
<org.jgrapht.graph.DefaultListenableGraph; fireEdgeRemoved[E]; void; org.jgrapht.graph.DefaultListenableGraph; removeEdge[E]; boolean; null; this>
<java.util.ArrayList; remove[java.lang.Object]; boolean; org.jgrapht.graph.DefaultListenableGraph; removeGraphListener[org.jgrapht.event.GraphListener<V,E>]; void; null; graphListeners>
<org.jgrapht.graph.GraphDelegator; containsVertex[V]; boolean; org.jgrapht.graph.DefaultListenableGraph; removeVertex[V]; boolean; null; this>
<org.jgrapht.graph.GraphDelegator; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.DefaultListenableGraph; removeVertex[V]; boolean; null; this>
<org.jgrapht.graph.AbstractGraph; removeAllEdges[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DefaultListenableGraph; removeVertex[V]; boolean; null; this>
<org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; org.jgrapht.graph.DefaultListenableGraph; removeVertex[V]; boolean; null; this>
<java.util.ArrayList; remove[java.lang.Object]; boolean; org.jgrapht.graph.DefaultListenableGraph; removeVertexSetListener[org.jgrapht.event.VertexSetListener<V>]; void; null; vertexSetListeners>
<org.jgrapht.graph.DefaultListenableGraph; createGraphEdgeChangeEvent[int, E]; org.jgrapht.event.GraphEdgeChangeEvent<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireEdgeAdded[E]; void; null; this>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireEdgeAdded[E]; void; null; graphListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.GraphListener<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireEdgeAdded[E]; void; null; graphListeners>
<org.jgrapht.event.GraphListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; org.jgrapht.graph.DefaultListenableGraph; fireEdgeAdded[E]; void; null; l>
<org.jgrapht.graph.DefaultListenableGraph; createGraphEdgeChangeEvent[int, E]; org.jgrapht.event.GraphEdgeChangeEvent<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireEdgeRemoved[E]; void; null; this>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireEdgeRemoved[E]; void; null; graphListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.GraphListener<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireEdgeRemoved[E]; void; null; graphListeners>
<org.jgrapht.event.GraphListener; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; org.jgrapht.graph.DefaultListenableGraph; fireEdgeRemoved[E]; void; null; l>
<org.jgrapht.graph.DefaultListenableGraph; createGraphVertexChangeEvent[int, V]; org.jgrapht.event.GraphVertexChangeEvent<V>; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; this>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; vertexSetListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.VertexSetListener<V>; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; vertexSetListeners>
<org.jgrapht.event.VertexSetListener; vertexAdded[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; l>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; graphListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.GraphListener<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; graphListeners>
<org.jgrapht.event.VertexSetListener; vertexAdded[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; l>
<org.jgrapht.graph.DefaultListenableGraph; createGraphVertexChangeEvent[int, V]; org.jgrapht.event.GraphVertexChangeEvent<V>; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; this>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; vertexSetListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.VertexSetListener<V>; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; vertexSetListeners>
<org.jgrapht.event.VertexSetListener; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; l>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; graphListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.GraphListener<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; graphListeners>
<org.jgrapht.event.VertexSetListener; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; l>
<java.util.List; contains[java.lang.Object]; boolean; org.jgrapht.graph.DefaultListenableGraph; addToListenerList[java.util.List<L>, L]; void; null; list>
<java.util.List; add[L]; boolean; org.jgrapht.graph.DefaultListenableGraph; addToListenerList[java.util.List<L>, L]; void; null; list>
<org.jgrapht.graph.DefaultListenableGraph$FlyweightEdgeEvent; setType[int]; void; org.jgrapht.graph.DefaultListenableGraph; createGraphEdgeChangeEvent[int, E]; org.jgrapht.event.GraphEdgeChangeEvent<V,E>; null; reuseableEdgeEvent>
<org.jgrapht.graph.DefaultListenableGraph$FlyweightEdgeEvent; setEdge[E]; void; org.jgrapht.graph.DefaultListenableGraph; createGraphEdgeChangeEvent[int, E]; org.jgrapht.event.GraphEdgeChangeEvent<V,E>; null; reuseableEdgeEvent>
<org.jgrapht.graph.DefaultListenableGraph$FlyweightVertexEvent; setType[int]; void; org.jgrapht.graph.DefaultListenableGraph; createGraphVertexChangeEvent[int, V]; org.jgrapht.event.GraphVertexChangeEvent<V>; null; reuseableVertexEvent>
<org.jgrapht.graph.DefaultListenableGraph$FlyweightVertexEvent; setVertex[V]; void; org.jgrapht.graph.DefaultListenableGraph; createGraphVertexChangeEvent[int, V]; org.jgrapht.event.GraphVertexChangeEvent<V>; null; reuseableVertexEvent>
<java.lang.Class; newInstance[]; ; org.jgrapht.graph.ClassBasedEdgeFactory; createEdge[V, V]; E; null; edgeClass>
<org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; org.jgrapht.graph.UndirectedGraphUnion; degreeOf[V]; int; null; this>
<java.util.Set; size[]; int; org.jgrapht.graph.UndirectedGraphUnion; degreeOf[V]; int; null; res>
<java.util.Set; size[]; int; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; sg.edgeSet()>
<org.jgrapht.graph.Subgraph; edgeSet[]; java.util.Set<E>; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; size[]; sg>
<java.util.Iterator; next[]; E; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; sg.edgeSet().iterator()>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; next[]; sg.edgeSet()>
<org.jgrapht.graph.Subgraph; edgeSet[]; java.util.Set<E>; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; iterator[]; sg>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; g>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; g>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; cover>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; cover>
<org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; sg>
<org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; sg>
<java.util.Set; size[]; int; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; null; sg.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; size[]; sg>
<java.util.Collections; max[java.util.Collection<? extends V>, java.util.Comparator<? super V>]; V; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; null; Collections>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; null; sg>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; null; cover>
<org.jgrapht.Graph; removeVertex[V]; boolean; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; null; sg>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.alg.EdmondsKarpMaximumFlow; EdmondsKarpMaximumFlow[org.jgrapht.DirectedGraph<V,E>, double]; void; null; network>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.alg.EdmondsKarpMaximumFlow; EdmondsKarpMaximumFlow[org.jgrapht.DirectedGraph<V,E>, double]; void; null; network>
<org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; org.jgrapht.alg.EdmondsKarpMaximumFlow; EdmondsKarpMaximumFlow[org.jgrapht.DirectedGraph<V,E>, double]; void; null; this>
<java.util.Set; size[]; int; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; size[]; network>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; iterator[]; network>
<java.util.Iterator; next[]; V; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; it>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; indexer>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; indexer>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes.get(i).outgoingArcs>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; nodes>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes.get(j).outgoingArcs>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; nodes>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; network>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; network>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; source>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; indexer>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; indexer>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; nodes>
<org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; this>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; nodes>
<java.util.Map; put[E, java.lang.Double]; java.lang.Double; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; maximumFlow>
<org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; this>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.Queue; offer[java.lang.Integer]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; queue>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.Collection; size[]; int; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; queue>
<java.util.Queue; poll[]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; queue>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.lang.Math; min[double, double]; double; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; Math>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.Queue; add[java.lang.Integer]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; queue>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; null; nodes>
<java.util.Collections; unmodifiableMap[java.util.Map<? extends E,? extends java.lang.Double>]; java.util.Map<E,java.lang.Double>; org.jgrapht.alg.EdmondsKarpMaximumFlow; getMaximumFlow[]; java.util.Map<E,java.lang.Double>; null; Collections>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; getCurrentSource[]; V; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; getCurrentSink[]; V; null; nodes>
<java.util.Set; size[]; int; org.jgrapht.alg.KShortestPaths; KShortestPaths[org.jgrapht.Graph<V,E>, V, int]; void; null; graph.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.KShortestPaths; KShortestPaths[org.jgrapht.Graph<V,E>, V, int]; void; size[]; graph>
<org.jgrapht.alg.KShortestPaths; assertKShortestPathsFinder[org.jgrapht.Graph<V,E>, V, int, int]; void; org.jgrapht.alg.KShortestPaths; KShortestPaths[org.jgrapht.Graph<V,E>, V, int, int]; void; null; this>
<org.jgrapht.alg.KShortestPaths; assertGetPaths[V]; void; org.jgrapht.alg.KShortestPaths; getPaths[V]; java.util.List<org.jgrapht.GraphPath<V,E>>; null; this>
<org.jgrapht.alg.KShortestPathsIterator; hasNext[]; boolean; org.jgrapht.alg.KShortestPaths; getPaths[V]; java.util.List<org.jgrapht.GraphPath<V,E>>; null; iter>
<org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; org.jgrapht.alg.KShortestPaths; getPaths[V]; java.util.List<org.jgrapht.GraphPath<V,E>>; null; iter>
<org.jgrapht.alg.KShortestPathsIterator; getPathElements[V]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPaths; getPaths[V]; java.util.List<org.jgrapht.GraphPath<V,E>>; null; iter>
<java.util.List; add[org.jgrapht.GraphPath<V,E>]; boolean; org.jgrapht.alg.KShortestPaths; getPaths[V]; java.util.List<org.jgrapht.GraphPath<V,E>>; null; pathList>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.KShortestPaths; assertGetPaths[V]; void; null; endVertex>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.KShortestPaths; assertGetPaths[V]; void; null; this.graph.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.KShortestPaths; assertGetPaths[V]; void; contains[java.lang.Object]; this.graph>
<org.jgrapht.alg.AbstractPathElement; getVertex[]; V; org.jgrapht.alg.KShortestPaths.PathWrapper; getEndVertex[]; V; null; rankingPathElement>
<org.jgrapht.alg.AbstractPathElement; createEdgeListPath[]; java.util.List<E>; org.jgrapht.alg.KShortestPaths.PathWrapper; getEdgeList[]; java.util.List<E>; null; rankingPathElement>
<org.jgrapht.alg.RankingPathElement; getWeight[]; double; org.jgrapht.alg.KShortestPaths.PathWrapper; getWeight[]; double; null; rankingPathElement>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.alg.KShortestPaths.PathWrapper; toString[]; java.lang.String; null; getEdgeList()>
<org.jgrapht.alg.KShortestPaths$PathWrapper; getEdgeList[]; java.util.List<E>; org.jgrapht.alg.KShortestPaths.PathWrapper; toString[]; java.lang.String; toString[]; this>
<java.util.Set; size[]; int; org.jgrapht.alg.BellmanFordShortestPath; BellmanFordShortestPath[org.jgrapht.Graph<V,E>, V]; void; null; graph.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.BellmanFordShortestPath; BellmanFordShortestPath[org.jgrapht.Graph<V,E>, V]; void; size[]; graph>
<org.jgrapht.alg.BellmanFordShortestPath; assertGetPath[V]; void; org.jgrapht.alg.BellmanFordShortestPath; getCost[V]; double; null; this>
<org.jgrapht.alg.BellmanFordShortestPath; lazyCalculate[]; void; org.jgrapht.alg.BellmanFordShortestPath; getCost[V]; double; null; this>
<org.jgrapht.alg.BellmanFordIterator; getPathElement[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordShortestPath; getCost[V]; double; null; this.iter>
<org.jgrapht.alg.BellmanFordPathElement; getCost[]; double; org.jgrapht.alg.BellmanFordShortestPath; getCost[V]; double; null; pathElement>
<org.jgrapht.alg.BellmanFordShortestPath; assertGetPath[V]; void; org.jgrapht.alg.BellmanFordShortestPath; getPathEdgeList[V]; java.util.List<E>; null; this>
<org.jgrapht.alg.BellmanFordShortestPath; lazyCalculate[]; void; org.jgrapht.alg.BellmanFordShortestPath; getPathEdgeList[V]; java.util.List<E>; null; this>
<org.jgrapht.alg.BellmanFordIterator; getPathElement[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordShortestPath; getPathEdgeList[V]; java.util.List<E>; null; this.iter>
<org.jgrapht.alg.AbstractPathElement; createEdgeListPath[]; java.util.List<E>; org.jgrapht.alg.BellmanFordShortestPath; getPathEdgeList[V]; java.util.List<E>; null; pathElement>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.BellmanFordShortestPath; assertGetPath[V]; void; null; endVertex>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.alg.BellmanFordShortestPath; assertGetPath[V]; void; null; this.graph>
<org.jgrapht.alg.BellmanFordIterator; hasNext[]; boolean; org.jgrapht.alg.BellmanFordShortestPath; lazyCalculate[]; void; null; this.iter>
<org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; org.jgrapht.alg.BellmanFordShortestPath; lazyCalculate[]; void; null; this.iter>
<org.jgrapht.alg.BellmanFordShortestPath; getPathEdgeList[V]; java.util.List<E>; org.jgrapht.alg.BellmanFordShortestPath; findPathBetween[org.jgrapht.Graph<V,E>, V, V]; java.util.List<E>; null; alg>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.alg.util.VertexDegreeComparator; compare[V, V]; int; null; graph>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.alg.util.VertexDegreeComparator; compare[V, V]; int; null; graph>
<org.jgrapht.alg.AbstractPathElement; getVertex[]; V; org.jgrapht.alg.AbstractPathElementList; AbstractPathElementList[org.jgrapht.Graph<V,E>, int, T]; void; null; pathElement>
<java.util.ArrayList; add[T]; boolean; org.jgrapht.alg.AbstractPathElementList; AbstractPathElementList[org.jgrapht.Graph<V,E>, int, T]; void; null; this.pathElements>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.AbstractPathElementList; AbstractPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.AbstractPathElementList<V,E,T>, E]; void; null; Graphs>
<org.jgrapht.alg.AbstractPathElementList; getVertex[]; V; org.jgrapht.alg.AbstractPathElementList; AbstractPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.AbstractPathElementList<V,E,T>, E]; void; null; elementList>
<java.util.ArrayList; addAll[java.util.Collection<? extends T>]; boolean; org.jgrapht.alg.AbstractPathElementList; AbstractPathElementList[org.jgrapht.alg.AbstractPathElementList<V,E,T>]; void; null; this.pathElements>
<java.util.ArrayList; get[int]; T; org.jgrapht.alg.AbstractPathElementList; get[int]; T; null; this.pathElements>
<java.util.ArrayList; size[]; int; org.jgrapht.alg.AbstractPathElementList; size[]; int; null; this.pathElements>
<org.jgrapht.alg.KShortestPathsIterator; assertKShortestPathsIterator[org.jgrapht.Graph<V,E>, V]; void; org.jgrapht.alg.KShortestPathsIterator; KShortestPathsIterator[org.jgrapht.Graph<V,E>, V, V, int]; void; null; this>
<org.jgrapht.alg.KShortestPathsIterator; encounterStartVertex[]; void; org.jgrapht.alg.KShortestPathsIterator; hasNext[]; boolean; null; this>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.alg.KShortestPathsIterator; hasNext[]; boolean; null; this.prevImprovedVertices>
<org.jgrapht.alg.KShortestPathsIterator; encounterStartVertex[]; void; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; this>
<org.jgrapht.alg.KShortestPathsIterator; hasNext[]; boolean; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; this>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; this.prevImprovedVertices>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; iter>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; vertex>
<org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; this>
<org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; this>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; getPathElements[V]; org.jgrapht.alg.RankingPathElementList<V,E>; null; this.seenDataContainer>
<org.jgrapht.alg.KShortestPathsIterator; createSeenData[V, E]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; addFirstPath[V, E]; void; null; this>
<java.util.Map; put[V, org.jgrapht.alg.RankingPathElementList<V,E>]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; addFirstPath[V, E]; void; null; this.seenDataContainer>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.KShortestPathsIterator; createSeenData[V, E]; org.jgrapht.alg.RankingPathElementList<V,E>; null; Graphs>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; createSeenData[V, E]; org.jgrapht.alg.RankingPathElementList<V,E>; null; this.prevSeenDataContainer>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.alg.KShortestPathsIterator; edgesOf[V]; java.util.Set<E>; null; ((DirectedGraph<V,E>)this.graph)>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.alg.KShortestPathsIterator; edgesOf[V]; java.util.Set<E>; null; this.graph>
<java.util.Map; put[V, org.jgrapht.alg.RankingPathElementList<V,E>]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; encounterStartVertex[]; void; null; this.seenDataContainer>
<java.util.Map; put[V, org.jgrapht.alg.RankingPathElementList<V,E>]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; encounterStartVertex[]; void; null; this.prevSeenDataContainer>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.KShortestPathsIterator; encounterStartVertex[]; void; null; this.prevImprovedVertices>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; null; improvedVertices>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; null; iter>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; null; this.seenDataContainer>
<java.util.Map; put[V, org.jgrapht.alg.RankingPathElementList<V,E>]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; null; this.prevSeenDataContainer>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; tryToAddNewPaths[V, E]; boolean; null; this.seenDataContainer>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.KShortestPathsIterator; tryToAddNewPaths[V, E]; boolean; null; Graphs>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; tryToAddNewPaths[V, E]; boolean; null; this.prevSeenDataContainer>
<org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; org.jgrapht.alg.KShortestPathsIterator; tryToAddNewPaths[V, E]; boolean; null; data>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; edgesOf(vertex)>
<org.jgrapht.alg.KShortestPathsIterator; edgesOf[V]; java.util.Set<E>; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; iterator[]; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; iter>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; Graphs>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; this.seenDataContainer>
<org.jgrapht.alg.KShortestPathsIterator; tryToAddNewPaths[V, E]; boolean; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; this>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; improvedVertices>
<org.jgrapht.alg.KShortestPathsIterator; addFirstPath[V, E]; void; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; this>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; improvedVertices>
<org.jgrapht.alg.ConnectivityInspector; init[]; void; org.jgrapht.alg.ConnectivityInspector; ConnectivityInspector[org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<org.jgrapht.alg.ConnectivityInspector; init[]; void; org.jgrapht.alg.ConnectivityInspector; ConnectivityInspector[org.jgrapht.DirectedGraph<V,E>]; void; null; this>
<java.util.List; size[]; int; org.jgrapht.alg.ConnectivityInspector; isGraphConnected[]; boolean; null; lazyFindConnectedSets()>
<org.jgrapht.alg.ConnectivityInspector; lazyFindConnectedSets[]; java.util.List<java.util.Set<V>>; org.jgrapht.alg.ConnectivityInspector; isGraphConnected[]; boolean; size[]; this>
<java.util.Map; get[java.lang.Object]; java.util.Set<V>; org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; null; vertexToConnectedSet>
<org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; null; i>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; null; connectedSet>
<org.jgrapht.traverse.CrossComponentIterator; next[]; V; org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; null; i>
<java.util.Map; put[V, java.util.Set<V>]; java.util.Set<V>; org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; null; vertexToConnectedSet>
<org.jgrapht.alg.ConnectivityInspector; lazyFindConnectedSets[]; java.util.List<java.util.Set<V>>; org.jgrapht.alg.ConnectivityInspector; connectedSets[]; java.util.List<java.util.Set<V>>; null; this>
<org.jgrapht.alg.ConnectivityInspector; init[]; void; org.jgrapht.alg.ConnectivityInspector; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.alg.ConnectivityInspector; init[]; void; org.jgrapht.alg.ConnectivityInspector; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; org.jgrapht.alg.ConnectivityInspector; pathExists[V, V]; boolean; null; this>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.ConnectivityInspector; pathExists[V, V]; boolean; null; sourceSet>
<org.jgrapht.alg.ConnectivityInspector; init[]; void; org.jgrapht.alg.ConnectivityInspector; vertexAdded[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; this>
<org.jgrapht.alg.ConnectivityInspector; init[]; void; org.jgrapht.alg.ConnectivityInspector; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; this>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.ConnectivityInspector; lazyFindConnectedSets[]; java.util.List<java.util.Set<V>>; null; graph>
<java.util.Set; size[]; int; org.jgrapht.alg.ConnectivityInspector; lazyFindConnectedSets[]; java.util.List<java.util.Set<V>>; null; vertexSet>
<org.jgrapht.traverse.AbstractGraphIterator; addTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; org.jgrapht.alg.ConnectivityInspector; lazyFindConnectedSets[]; java.util.List<java.util.Set<V>>; null; i>
<org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; org.jgrapht.alg.ConnectivityInspector; lazyFindConnectedSets[]; java.util.List<java.util.Set<V>>; null; i>
<org.jgrapht.traverse.CrossComponentIterator; next[]; V; org.jgrapht.alg.ConnectivityInspector; lazyFindConnectedSets[]; java.util.List<java.util.Set<V>>; null; i>
<java.util.List; add[java.util.Set<V>]; boolean; org.jgrapht.alg.ConnectivityInspector.MyTraversalListener; connectedComponentFinished[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; null; connectedSets>
<org.jgrapht.event.VertexTraversalEvent; getVertex[]; V; org.jgrapht.alg.ConnectivityInspector.MyTraversalListener; vertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; e>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.ConnectivityInspector.MyTraversalListener; vertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; currentConnectedSet>
<java.util.Map; put[V, java.util.Set<V>]; java.util.Set<V>; org.jgrapht.alg.ConnectivityInspector.MyTraversalListener; vertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; vertexToConnectedSet>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.AbstractPathElement; AbstractPathElement[org.jgrapht.Graph<V,E>, org.jgrapht.alg.AbstractPathElement<V,E>, E]; void; null; Graphs>
<org.jgrapht.alg.AbstractPathElement; getVertex[]; V; org.jgrapht.alg.AbstractPathElement; AbstractPathElement[org.jgrapht.Graph<V,E>, org.jgrapht.alg.AbstractPathElement<V,E>, E]; void; null; pathElement>
<org.jgrapht.alg.AbstractPathElement; getHopCount[]; int; org.jgrapht.alg.AbstractPathElement; AbstractPathElement[org.jgrapht.Graph<V,E>, org.jgrapht.alg.AbstractPathElement<V,E>, E]; void; null; pathElement>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.AbstractPathElement; createEdgeListPath[]; java.util.List<E>; null; pathElement>
<java.util.List; add[E]; boolean; org.jgrapht.alg.AbstractPathElement; createEdgeListPath[]; java.util.List<E>; null; path>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.AbstractPathElement; createEdgeListPath[]; java.util.List<E>; null; pathElement>
<org.jgrapht.alg.AbstractPathElement; getPrevPathElement[]; org.jgrapht.alg.AbstractPathElement<V,E>; org.jgrapht.alg.AbstractPathElement; createEdgeListPath[]; java.util.List<E>; null; pathElement>
<java.util.Collections; reverse[java.util.List<?>]; void; org.jgrapht.alg.AbstractPathElement; createEdgeListPath[]; java.util.List<E>; null; Collections>
<org.jgrapht.graph.AbstractBaseGraph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.Set; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g.edgeSet()>
<org.jgrapht.graph.AbstractBaseGraph; edgeSet[]; java.util.Set<E>; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; size[]; g>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; tour>
<java.util.Set; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g.vertexSet()>
<org.jgrapht.graph.AbstractBaseGraph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; size[]; g>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; tour>
<java.util.List; get[int]; V; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; tour>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeWeight[E]; double; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g>
<org.jgrapht.graph.AbstractBaseGraph; getEdge[V, V]; E; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g>
<java.util.List; get[int]; V; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.List; add[int, V]; void; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; tour>
<java.util.List; get[int]; V; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.List; remove[int]; V; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.Iterator; next[]; V; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; graph.vertexSet().iterator()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; next[]; graph.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; iterator[]; graph>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.dfsTree>
<org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<java.util.Set; size[]; int; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.dfsTree.edgesOf(s)>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<org.jgrapht.graph.DefaultEdge>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; size[]; this.dfsTree>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.cutpoints>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.cutpoints>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.cutpoints>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; iter>
<org.jgrapht.Graph; getEdgeFactory[]; org.jgrapht.EdgeFactory<V,E>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.graph>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; subgraph>
<java.util.Map; put[V, org.jgrapht.UndirectedGraph<V,E>]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.vertex2block>
<org.jgrapht.graph.AbstractBaseGraph; addVertex[org.jgrapht.UndirectedGraph<V,E>]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<org.jgrapht.alg.BlockCutpointGraph; getBiconnectedSubgraphs[V]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<java.util.Set; iterator[]; java.util.Iterator<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; biconnectedSubgraphs>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; iterator>
<java.util.Iterator; next[]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; iterator>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; vertexSet()>
<org.jgrapht.graph.AbstractBaseGraph; vertexSet[]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; contains[java.lang.Object]; this>
<org.jgrapht.graph.AbstractBaseGraph; addEdge[org.jgrapht.UndirectedGraph<V,E>, org.jgrapht.UndirectedGraph<V,E>]; org.jgrapht.graph.DefaultEdge; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; getBlock[V]; org.jgrapht.UndirectedGraph<V,E>; null; this.graph.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.BlockCutpointGraph; getBlock[V]; org.jgrapht.UndirectedGraph<V,E>; contains[java.lang.Object]; this.graph>
<java.util.Map; get[java.lang.Object]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.alg.BlockCutpointGraph; getBlock[V]; org.jgrapht.UndirectedGraph<V,E>; null; this.vertex2block>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; isCutpoint[V]; boolean; null; this.graph.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.BlockCutpointGraph; isCutpoint[V]; boolean; contains[java.lang.Object]; this.graph>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; isCutpoint[V]; boolean; null; this.cutpoints>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.cutpoints>
<java.util.Deque; removeLast[]; org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.stack>
<org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this>
<org.jgrapht.alg.BlockCutpointGraph$BCGEdge; getSource[]; V; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edge>
<org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.stack>
<java.util.Set; add[org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edgeComponent>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<org.jgrapht.alg.BlockCutpointGraph$BCGEdge; getSource[]; V; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edge>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<org.jgrapht.alg.BlockCutpointGraph$BCGEdge; getTarget[]; V; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edge>
<java.util.Deque; removeLast[]; org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.stack>
<java.util.Set; add[org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edgeComponent>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<org.jgrapht.alg.BlockCutpointGraph$BCGEdge; getSource[]; V; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edge>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<org.jgrapht.alg.BlockCutpointGraph$BCGEdge; getTarget[]; V; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edge>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; iter>
<java.util.Map; put[V, org.jgrapht.UndirectedGraph<V,E>]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.vertex2block>
<java.util.Set; add[org.jgrapht.UndirectedGraph<V,E>]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; getBiconnectedSubgraphs(vertex)>
<org.jgrapht.alg.BlockCutpointGraph; getBiconnectedSubgraphs[V]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; add[org.jgrapht.UndirectedGraph<V,E>]; this>
<org.jgrapht.graph.AbstractBaseGraph; addVertex[org.jgrapht.UndirectedGraph<V,E>]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this>
<org.jgrapht.alg.BlockCutpointGraph; setNumOrder[V, int]; void; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this.graph.edgesOf(s)>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; iterator[]; this.graph>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; iter>
<java.util.Iterator; next[]; E; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; iter>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; Graphs>
<org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this>
<org.jgrapht.Graph; addVertex[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this.dfsTree>
<org.jgrapht.Graph; addEdge[V, V, org.jgrapht.graph.DefaultEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this.dfsTree>
<java.util.Deque; add[org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this.stack>
<org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this>
<java.lang.Math; min[int, int]; int; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; Math>
<org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this>
<org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this>
<org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this>
<org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; n>
<java.util.Deque; add[org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this.stack>
<java.lang.Math; min[int, int]; int; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; Math>
<org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this>
<java.util.Map; get[java.lang.Object]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; getBiconnectedSubgraphs[V]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; null; this.vertex2biconnectedSubgraphs>
<java.util.Map; put[V, java.util.Set<org.jgrapht.UndirectedGraph<V,E>>]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; getBiconnectedSubgraphs[V]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; null; this.vertex2biconnectedSubgraphs>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; null; this.vertex2numOrder>
<java.lang.Integer; intValue[]; int; org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; null; numOrder>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.alg.BlockCutpointGraph; setNumOrder[V, int]; void; null; this.vertex2numOrder>
<java.lang.Integer; valueOf[int]; java.lang.Integer; org.jgrapht.alg.BlockCutpointGraph; setNumOrder[V, int]; void; null; Integer>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph.VertexComponentForbiddenFunction; isVertexMasked[V]; boolean; null; this.vertexComponent>
<java.util.Set; iterator[]; java.util.Iterator<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; this.blockCutpointGraph.vertexSet()>
<org.jgrapht.graph.AbstractBaseGraph; vertexSet[]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; iterator[]; this.blockCutpointGraph>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; iter>
<java.util.Iterator; next[]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; iter>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; subgraph.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; isEmpty[]; subgraph>
<java.util.Set; add[java.util.Set<V>]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; biconnectedVertexComponents>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; subgraph>
<java.util.Set; iterator[]; java.util.Iterator<java.util.Set<V>>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; null; getBiconnectedVertexComponents()>
<org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; iterator[]; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; null; iter>
<java.util.Iterator; next[]; java.util.Set<V>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; null; iter>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; null; vertexComponent>
<java.util.Set; add[java.util.Set<V>]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; null; vertexComponents>
<org.jgrapht.alg.BlockCutpointGraph; getCutpoints[]; java.util.Set<V>; org.jgrapht.alg.BiconnectivityInspector; getCutpoints[]; java.util.Set<V>; null; this.blockCutpointGraph>
<java.util.Set; size[]; int; org.jgrapht.alg.BiconnectivityInspector; isBiconnected[]; boolean; null; this.blockCutpointGraph.vertexSet()>
<org.jgrapht.graph.AbstractBaseGraph; vertexSet[]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BiconnectivityInspector; isBiconnected[]; boolean; size[]; this.blockCutpointGraph>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.alg.DijkstraShortestPath; DijkstraShortestPath[org.jgrapht.Graph<V,E>, V, V, double]; void; null; graph>
<org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; org.jgrapht.alg.DijkstraShortestPath; DijkstraShortestPath[org.jgrapht.Graph<V,E>, V, V, double]; void; null; iter>
<org.jgrapht.traverse.CrossComponentIterator; next[]; V; org.jgrapht.alg.DijkstraShortestPath; DijkstraShortestPath[org.jgrapht.Graph<V,E>, V, V, double]; void; null; iter>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.DijkstraShortestPath; DijkstraShortestPath[org.jgrapht.Graph<V,E>, V, V, double]; void; null; vertex>
<org.jgrapht.alg.DijkstraShortestPath; createEdgeList[org.jgrapht.Graph<V,E>, org.jgrapht.traverse.ClosestFirstIterator<V,E>, V, V]; void; org.jgrapht.alg.DijkstraShortestPath; DijkstraShortestPath[org.jgrapht.Graph<V,E>, V, V, double]; void; null; this>
<org.jgrapht.GraphPath; getEdgeList[]; java.util.List<E>; org.jgrapht.alg.DijkstraShortestPath; getPathEdgeList[]; java.util.List<E>; null; path>
<org.jgrapht.GraphPath; getWeight[]; double; org.jgrapht.alg.DijkstraShortestPath; getPathLength[]; double; null; path>
<org.jgrapht.alg.DijkstraShortestPath; getPathEdgeList[]; java.util.List<E>; org.jgrapht.alg.DijkstraShortestPath; findPathBetween[org.jgrapht.Graph<V,E>, V, V]; java.util.List<E>; null; alg>
<org.jgrapht.traverse.ClosestFirstIterator; getSpanningTreeEdge[V]; E; org.jgrapht.alg.DijkstraShortestPath; createEdgeList[org.jgrapht.Graph<V,E>, org.jgrapht.traverse.ClosestFirstIterator<V,E>, V, V]; void; null; iter>
<java.util.List; add[E]; boolean; org.jgrapht.alg.DijkstraShortestPath; createEdgeList[org.jgrapht.Graph<V,E>, org.jgrapht.traverse.ClosestFirstIterator<V,E>, V, V]; void; null; edgeList>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.DijkstraShortestPath; createEdgeList[org.jgrapht.Graph<V,E>, org.jgrapht.traverse.ClosestFirstIterator<V,E>, V, V]; void; null; Graphs>
<java.util.Collections; reverse[java.util.List<?>]; void; org.jgrapht.alg.DijkstraShortestPath; createEdgeList[org.jgrapht.Graph<V,E>, org.jgrapht.traverse.ClosestFirstIterator<V,E>, V, V]; void; null; Collections>
<org.jgrapht.traverse.ClosestFirstIterator; getShortestPathLength[V]; double; org.jgrapht.alg.DijkstraShortestPath; createEdgeList[org.jgrapht.Graph<V,E>, org.jgrapht.traverse.ClosestFirstIterator<V,E>, V, V]; void; null; iter>
<java.util.Set; size[]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; size[]; g>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.Graph; getEdge[V, V]; E; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<java.lang.Math; min[double, double]; double; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; Math>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<java.lang.Math; max[double, double]; double; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; Math>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; shortestDistance[V, V]; double; null; this>
<org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; org.jgrapht.alg.FloydWarshallShortestPaths; shortestDistance[V, V]; double; null; this>
<java.util.HashMap; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; null; indices>
<java.util.HashMap; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; null; indices>
<org.jgrapht.alg.NeighborIndex$Neighbors; getNeighbors[]; java.util.Set<V>; org.jgrapht.alg.NeighborIndex; neighborsOf[V]; java.util.Set<V>; null; getNeighbors(v)>
<org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; neighborsOf[V]; java.util.Set<V>; getNeighbors[]; this>
<org.jgrapht.alg.NeighborIndex$Neighbors; getNeighborList[]; java.util.List<V>; org.jgrapht.alg.NeighborIndex; neighborListOf[V]; java.util.List<V>; null; getNeighbors(v)>
<org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; neighborListOf[V]; java.util.List<V>; getNeighborList[]; this>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; graph>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; graph>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap>
<org.jgrapht.alg.NeighborIndex$Neighbors; addNeighbor[V]; void; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; getNeighbors(source)>
<org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; addNeighbor[V]; this>
<org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap>
<org.jgrapht.alg.NeighborIndex$Neighbors; addNeighbor[V]; void; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; getNeighbors(target)>
<org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; addNeighbor[V]; this>
<org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; graph>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; graph>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap>
<org.jgrapht.alg.NeighborIndex$Neighbors; removeNeighbor[V]; void; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap.get(source)>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; removeNeighbor[V]; neighborMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap>
<org.jgrapht.alg.NeighborIndex$Neighbors; removeNeighbor[V]; void; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap.get(target)>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; removeNeighbor[V]; neighborMap>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; neighborMap>
<org.jgrapht.event.GraphVertexChangeEvent; getVertex[]; V; org.jgrapht.alg.NeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; e>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; neighborMap>
<org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; Graphs>
<java.util.Map; put[V, org.jgrapht.alg.NeighborIndex.Neighbors<V,E>]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; neighborMap>
<java.util.Collections; unmodifiableSet[java.util.Set<? extends V>]; java.util.Set<V>; org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; Collections>
<java.util.Map; keySet[]; java.util.Set<V>; org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; neighborCounts>
<org.jgrapht.alg.NeighborIndex$Neighbors; addNeighbor[V]; void; org.jgrapht.alg.NeighborIndex.Neighbors; Neighbors[V, java.util.Collection<V>]; void; null; this>
<java.util.Map; get[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; addNeighbor[V]; void; null; neighborCounts>
<java.util.Map; put[V, org.jgrapht.util.ModifiableInteger]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; addNeighbor[V]; void; null; neighborCounts>
<org.jgrapht.util.ModifiableInteger; increment[]; void; org.jgrapht.alg.NeighborIndex.Neighbors; addNeighbor[V]; void; null; count>
<java.util.Map; get[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; removeNeighbor[V]; void; null; neighborCounts>
<org.jgrapht.util.ModifiableInteger; decrement[]; void; org.jgrapht.alg.NeighborIndex.Neighbors; removeNeighbor[V]; void; null; count>
<org.jgrapht.util.ModifiableInteger; getValue[]; int; org.jgrapht.alg.NeighborIndex.Neighbors; removeNeighbor[V]; void; null; count>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; removeNeighbor[V]; void; null; neighborCounts>
<java.util.Map; entrySet[]; java.util.Set<java.util.Map.Entry<V,org.jgrapht.util.ModifiableInteger>>; org.jgrapht.alg.NeighborIndex.Neighbors; getNeighborList[]; java.util.List<V>; null; neighborCounts>
<java.util.Map$Entry; getKey[]; V; org.jgrapht.alg.NeighborIndex.Neighbors; getNeighborList[]; java.util.List<V>; null; entry>
<org.jgrapht.util.ModifiableInteger; intValue[]; int; org.jgrapht.alg.NeighborIndex.Neighbors; getNeighborList[]; java.util.List<V>; null; entry.getValue()>
<java.util.Map$Entry; getValue[]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; getNeighborList[]; java.util.List<V>; intValue[]; entry>
<java.util.List; add[V]; boolean; org.jgrapht.alg.NeighborIndex.Neighbors; getNeighborList[]; java.util.List<V>; null; neighbors>
<org.jgrapht.alg.ConnectivityInspector; isGraphConnected[]; boolean; org.jgrapht.alg.EulerianCircuit; isEulerian[org.jgrapht.UndirectedGraph<V,E>]; boolean; null; (new ConnectivityInspector<V,E>(g))>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EulerianCircuit; isEulerian[org.jgrapht.UndirectedGraph<V,E>]; boolean; null; g.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.EulerianCircuit; isEulerian[org.jgrapht.UndirectedGraph<V,E>]; boolean; iterator[]; g>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.EulerianCircuit; isEulerian[org.jgrapht.UndirectedGraph<V,E>]; boolean; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.EulerianCircuit; isEulerian[org.jgrapht.UndirectedGraph<V,E>]; boolean; null; iter>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.alg.EulerianCircuit; isEulerian[org.jgrapht.UndirectedGraph<V,E>]; boolean; null; g>
<org.jgrapht.alg.EulerianCircuit; isEulerian[org.jgrapht.UndirectedGraph<V,E>]; boolean; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; this>
<java.util.List; add[V]; boolean; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; path>
<java.util.Iterator; next[]; V; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg.vertexSet().iterator()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; next[]; sg.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; iterator[]; sg>
<java.util.Set; size[]; int; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg.edgeSet()>
<org.jgrapht.Graph; edgeSet[]; java.util.Set<E>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; size[]; sg>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; path>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; iter>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg>
<org.jgrapht.UndirectedGraph; degreeOf[V]; int; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; iterator[]; sg>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; iter>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg>
<java.util.List; add[int, V]; void; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; path>
<org.jgrapht.Graph; removeEdge[V, V]; E; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; sg>
<java.util.Collections; sort[java.util.List<V>, java.util.Comparator<? super V>]; void; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; Collections>
<java.util.Collections; reverse[java.util.List<?>]; void; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; Collections>
<java.util.Set; size[]; int; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; sg.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; size[]; sg>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; sortedVertices>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; iter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; iter>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; currentColor>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; innerIter>
<java.util.Iterator; next[]; V; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; innerIter>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; sg>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; currentColor>
<org.jgrapht.Graph; removeAllVertices[java.util.Collection<? extends V>]; boolean; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; sg>
<org.jgrapht.alg.BellmanFordIterator; assertBellmanFordIterator[org.jgrapht.Graph<V,E>, V]; void; org.jgrapht.alg.BellmanFordIterator; BellmanFordIterator[org.jgrapht.Graph<V,E>, V, double]; void; null; this>
<org.jgrapht.alg.BellmanFordIterator; getSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; getPathElement[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this>
<org.jgrapht.alg.BellmanFordIterator; encounterStartVertex[]; void; org.jgrapht.alg.BellmanFordIterator; hasNext[]; boolean; null; this>
<java.util.List; isEmpty[]; boolean; org.jgrapht.alg.BellmanFordIterator; hasNext[]; boolean; null; this.prevImprovedVertices>
<org.jgrapht.alg.BellmanFordIterator; encounterStartVertex[]; void; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this>
<org.jgrapht.alg.BellmanFordIterator; hasNext[]; boolean; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this>
<java.util.List; size[]; int; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this.prevImprovedVertices>
<java.util.List; get[int]; V; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this.prevImprovedVertices>
<org.jgrapht.alg.BellmanFordIterator; edgesOfIterator[V]; java.util.Iterator<E>; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; iter>
<java.util.Iterator; next[]; ; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; iter>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; Graphs>
<org.jgrapht.alg.BellmanFordIterator; getPathElement[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this>
<org.jgrapht.alg.BellmanFordIterator; relaxVertexAgain[V, E]; boolean; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; improvedVertices>
<org.jgrapht.alg.BellmanFordIterator; relaxVertex[V, E]; void; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; improvedVertices>
<org.jgrapht.alg.BellmanFordIterator; savePassData[java.util.List<V>]; void; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.alg.BellmanFordIterator; assertValidEdge[E]; void; null; graph>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.BellmanFordIterator; calculatePathCost[V, E]; double; null; Graphs>
<org.jgrapht.alg.BellmanFordIterator; getPrevSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; calculatePathCost[V, E]; double; null; this>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.alg.BellmanFordIterator; calculatePathCost[V, E]; double; null; graph>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.BellmanFordIterator; calculatePathCost[V, E]; double; null; oppositePrevData.getVertex()>
<org.jgrapht.alg.AbstractPathElement; getVertex[]; V; org.jgrapht.alg.BellmanFordIterator; calculatePathCost[V, E]; double; equals[java.lang.Object]; oppositePrevData>
<org.jgrapht.alg.BellmanFordPathElement; getCost[]; double; org.jgrapht.alg.BellmanFordIterator; calculatePathCost[V, E]; double; null; oppositePrevData>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.BellmanFordIterator; edgesOfIterator[V]; java.util.Iterator<E>; null; ((DirectedGraph<V,E>)this.graph).outgoingEdgesOf(vertex)>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.alg.BellmanFordIterator; edgesOfIterator[V]; java.util.Iterator<E>; iterator[]; ((DirectedGraph<V,E>)this.graph)>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.BellmanFordIterator; edgesOfIterator[V]; java.util.Iterator<E>; null; this.graph.edgesOf(vertex)>
<org.jgrapht.Graph; edgesOf[V]; java.util.Set<E>; org.jgrapht.alg.BellmanFordIterator; edgesOfIterator[V]; java.util.Iterator<E>; iterator[]; this.graph>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; getPrevSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this.prevVertexData>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; getSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this.vertexData>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.BellmanFordIterator; isSeenVertex[V]; boolean; null; this.vertexData>
<java.util.Map; put[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; putPrevSeenData[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this.prevVertexData>
<java.util.Map; put[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; putSeenData[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this.vertexData>
<org.jgrapht.Graph; containsVertex[V]; boolean; org.jgrapht.alg.BellmanFordIterator; assertBellmanFordIterator[org.jgrapht.Graph<V,E>, V]; void; null; graph>
<org.jgrapht.alg.BellmanFordIterator; getPrevSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; createSeenData[V, E, double]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.BellmanFordIterator; createSeenData[V, E, double]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; Graphs>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BellmanFordIterator; encounterStartVertex[]; void; null; this.prevImprovedVertices>
<org.jgrapht.alg.BellmanFordIterator; putSeenData[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; encounterStartVertex[]; void; null; this>
<org.jgrapht.alg.BellmanFordIterator; putPrevSeenData[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; encounterStartVertex[]; void; null; this>
<org.jgrapht.alg.BellmanFordIterator; assertValidEdge[E]; void; org.jgrapht.alg.BellmanFordIterator; relaxVertex[V, E]; void; null; this>
<org.jgrapht.alg.BellmanFordIterator; calculatePathCost[V, E]; double; org.jgrapht.alg.BellmanFordIterator; relaxVertex[V, E]; void; null; this>
<org.jgrapht.alg.BellmanFordIterator; createSeenData[V, E, double]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; relaxVertex[V, E]; void; null; this>
<org.jgrapht.alg.BellmanFordIterator; putSeenData[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; relaxVertex[V, E]; void; null; this>
<org.jgrapht.alg.BellmanFordIterator; assertValidEdge[E]; void; org.jgrapht.alg.BellmanFordIterator; relaxVertexAgain[V, E]; boolean; null; this>
<org.jgrapht.alg.BellmanFordIterator; calculatePathCost[V, E]; double; org.jgrapht.alg.BellmanFordIterator; relaxVertexAgain[V, E]; boolean; null; this>
<org.jgrapht.alg.BellmanFordIterator; getPrevSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; relaxVertexAgain[V, E]; boolean; null; this>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.BellmanFordIterator; relaxVertexAgain[V, E]; boolean; null; Graphs>
<org.jgrapht.alg.BellmanFordIterator; getSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; relaxVertexAgain[V, E]; boolean; null; this>
<org.jgrapht.alg.BellmanFordPathElement; improve[org.jgrapht.alg.BellmanFordPathElement<V,E>, E, double]; boolean; org.jgrapht.alg.BellmanFordIterator; relaxVertexAgain[V, E]; boolean; null; pathElement>
<org.jgrapht.alg.BellmanFordIterator; getSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; savePassData[java.util.List<V>]; void; null; this>
<org.jgrapht.alg.BellmanFordIterator; putPrevSeenData[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; savePassData[java.util.List<V>]; void; null; this>
<org.jgrapht.alg.NeighborIndex$Neighbors; getNeighbors[]; java.util.Set<V>; org.jgrapht.alg.DirectedNeighborIndex; predecessorsOf[V]; java.util.Set<V>; null; getPredecessors(v)>
<org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; predecessorsOf[V]; java.util.Set<V>; getNeighbors[]; this>
<org.jgrapht.alg.NeighborIndex$Neighbors; getNeighborList[]; java.util.List<V>; org.jgrapht.alg.DirectedNeighborIndex; predecessorListOf[V]; java.util.List<V>; null; getPredecessors(v)>
<org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; predecessorListOf[V]; java.util.List<V>; getNeighborList[]; this>
<org.jgrapht.alg.NeighborIndex$Neighbors; getNeighbors[]; java.util.Set<V>; org.jgrapht.alg.DirectedNeighborIndex; successorsOf[V]; java.util.Set<V>; null; getSuccessors(v)>
<org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; successorsOf[V]; java.util.Set<V>; getNeighbors[]; this>
<org.jgrapht.alg.NeighborIndex$Neighbors; getNeighborList[]; java.util.List<V>; org.jgrapht.alg.DirectedNeighborIndex; successorListOf[V]; java.util.List<V>; null; getSuccessors(v)>
<org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; successorListOf[V]; java.util.List<V>; getNeighborList[]; this>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; graph>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; graph>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; successorMap>
<org.jgrapht.alg.NeighborIndex$Neighbors; addNeighbor[V]; void; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; getSuccessors(source)>
<org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; addNeighbor[V]; this>
<org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; predecessorMap>
<org.jgrapht.alg.NeighborIndex$Neighbors; addNeighbor[V]; void; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; getPredecessors(target)>
<org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; addNeighbor[V]; this>
<org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; this>
<org.jgrapht.event.GraphEdgeChangeEvent; getEdge[]; E; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; e>
<org.jgrapht.Graph; getEdgeSource[E]; V; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; graph>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; graph>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; successorMap>
<org.jgrapht.alg.NeighborIndex$Neighbors; removeNeighbor[V]; void; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; successorMap.get(source)>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; removeNeighbor[V]; successorMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; predecessorMap>
<org.jgrapht.alg.NeighborIndex$Neighbors; removeNeighbor[V]; void; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; predecessorMap.get(target)>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; removeNeighbor[V]; predecessorMap>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; predecessorMap>
<org.jgrapht.event.GraphVertexChangeEvent; getVertex[]; V; org.jgrapht.alg.DirectedNeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; e>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; successorMap>
<org.jgrapht.event.GraphVertexChangeEvent; getVertex[]; V; org.jgrapht.alg.DirectedNeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; e>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; predecessorMap>
<org.jgrapht.Graphs; predecessorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; Graphs>
<java.util.Map; put[V, org.jgrapht.alg.NeighborIndex.Neighbors<V,E>]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; predecessorMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; successorMap>
<org.jgrapht.Graphs; successorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; Graphs>
<java.util.Map; put[V, org.jgrapht.alg.NeighborIndex.Neighbors<V,E>]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; successorMap>
<org.jgrapht.alg.CycleDetector; execute[java.util.Set<V>, V]; void; org.jgrapht.alg.CycleDetector; detectCycles[]; boolean; null; this>
<org.jgrapht.alg.CycleDetector; execute[java.util.Set<V>, V]; void; org.jgrapht.alg.CycleDetector; detectCyclesContainingVertex[V]; boolean; null; this>
<org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; inspector>
<java.util.Set; size[]; int; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; component>
<java.util.Set; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; set>
<java.util.Iterator; next[]; V; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; component.iterator()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; next[]; component>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; graph>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; set>
<org.jgrapht.alg.CycleDetector; execute[java.util.Set<V>, V]; void; org.jgrapht.alg.CycleDetector; findCyclesContainingVertex[V]; java.util.Set<V>; null; this>
<org.jgrapht.traverse.CrossComponentIterator; hasNext[]; boolean; org.jgrapht.alg.CycleDetector; execute[java.util.Set<V>, V]; void; null; iter>
<org.jgrapht.traverse.CrossComponentIterator; next[]; V; org.jgrapht.alg.CycleDetector; execute[java.util.Set<V>, V]; void; null; iter>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; cycleSet>
<java.util.List; indexOf[java.lang.Object]; int; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; path>
<java.util.List; size[]; int; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; path>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; cycleSet>
<java.util.List; get[int]; V; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; path>
<java.util.List; size[]; int; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; path>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; graph>
<java.util.List; get[int]; V; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; path>
<java.util.List; remove[int]; V; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; path>
<java.util.List; add[V]; boolean; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; path>
<java.util.List; size[]; int; org.jgrapht.alg.StrongConnectivityInspector; isStronglyConnected[]; boolean; null; stronglyConnectedSets()>
<org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; org.jgrapht.alg.StrongConnectivityInspector; isStronglyConnected[]; boolean; size[]; this>
<org.jgrapht.alg.StrongConnectivityInspector; createVertexData[]; void; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; this>
<java.util.Map; values[]; java.util.Collection<org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>>; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; vertexToVertexData>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; isDiscovered[]; boolean; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; data>
<org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; this>
<org.jgrapht.alg.StrongConnectivityInspector; resetVertexData[]; void; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; this>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; isDiscovered[]; boolean; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; data>
<java.util.List; add[java.util.Set<V>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; stronglyConnectedSets>
<org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; this>
<org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSubgraphs[]; java.util.List<org.jgrapht.graph.DirectedSubgraph<V,E>>; null; this>
<java.util.List; size[]; int; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSubgraphs[]; java.util.List<org.jgrapht.graph.DirectedSubgraph<V,E>>; null; sets>
<java.util.List; add[org.jgrapht.graph.DirectedSubgraph<V,E>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSubgraphs[]; java.util.List<org.jgrapht.graph.DirectedSubgraph<V,E>>; null; stronglyConnectedSubgraphs>
<java.util.Set; size[]; int; org.jgrapht.alg.StrongConnectivityInspector; createVertexData[]; void; null; graph.vertexSet()>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.StrongConnectivityInspector; createVertexData[]; void; size[]; graph>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.StrongConnectivityInspector; createVertexData[]; void; null; graph>
<java.util.Map; put[V, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>; org.jgrapht.alg.StrongConnectivityInspector; createVertexData[]; void; null; vertexToVertexData>
<java.util.Deque; add[org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<java.util.Deque; removeLast[]; org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; isDiscovered[]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; data>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; setDiscovered[boolean]; void; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; data>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; vertices>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; getVertex[]; V; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; data>
<java.util.Deque; add[org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<org.jgrapht.DirectedGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; visitedGraph>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; getVertex[]; V; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; data>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; vertexToVertexData>
<org.jgrapht.Graph; getEdgeTarget[E]; V; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; visitedGraph>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; isDiscovered[]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; targetData>
<java.util.Deque; add[org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; isFinished[]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; data>
<java.util.LinkedList; addFirst[org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; void; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; orderedVertices>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; getFinishedData[]; org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; data>
<java.util.Map; values[]; java.util.Collection<org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>>; org.jgrapht.alg.StrongConnectivityInspector; resetVertexData[]; void; null; vertexToVertexData>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; setDiscovered[boolean]; void; org.jgrapht.alg.StrongConnectivityInspector; resetVertexData[]; void; null; data>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; setFinished[boolean]; void; org.jgrapht.alg.StrongConnectivityInspector; resetVertexData[]; void; null; data>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; setDiscovered[boolean]; void; org.jgrapht.alg.StrongConnectivityInspector.VertexData; VertexData[boolean, boolean]; void; null; this>
<org.jgrapht.alg.StrongConnectivityInspector$VertexData; setFinished[boolean]; void; org.jgrapht.alg.StrongConnectivityInspector.VertexData; VertexData[boolean, boolean]; void; null; this>
<org.jgrapht.graph.AbstractBaseGraph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; graph>
<org.jgrapht.alg.TransitiveClosure; computeBinaryLog[int]; int; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; this>
<java.util.Set; size[]; int; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; vertexSet>
<java.util.Set; clear[]; void; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; newEdgeTargets>
<org.jgrapht.graph.AbstractBaseGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; graph>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; graph>
<org.jgrapht.graph.AbstractBaseGraph; outgoingEdgesOf[V]; java.util.Set<E>; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; graph>
<org.jgrapht.graph.AbstractBaseGraph; getEdgeTarget[E]; V; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; graph>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; v1>
<org.jgrapht.graph.AbstractBaseGraph; getEdge[V, V]; E; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; graph>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; newEdgeTargets>
<org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; graph>
<org.jgrapht.alg.BellmanFordPathElement; getCost[]; double; org.jgrapht.alg.BellmanFordPathElement; improve[org.jgrapht.alg.BellmanFordPathElement<V,E>, E, double]; boolean; null; this>
<org.jgrapht.alg.AbstractPathElement; getHopCount[]; int; org.jgrapht.alg.BellmanFordPathElement; improve[org.jgrapht.alg.BellmanFordPathElement<V,E>, E, double]; boolean; null; candidatePrevPathElement>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; elementList>
<org.jgrapht.alg.AbstractPathElementList; get[int]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; elementList>
<java.util.ArrayList; size[]; int; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; this.pathElements>
<org.jgrapht.alg.RankingPathElementList; calculatePathWeight[org.jgrapht.alg.RankingPathElement<V,E>, E]; double; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; this>
<java.util.ArrayList; add[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; this.pathElements>
<java.util.ArrayList; isEmpty[]; boolean; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; this.pathElements>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.vertex>
<org.jgrapht.Graphs; getOppositeVertex[org.jgrapht.Graph<V,E>, E, V]; V; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; Graphs>
<org.jgrapht.alg.AbstractPathElementList; getVertex[]; V; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; elementList>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; elementList>
<org.jgrapht.alg.AbstractPathElementList; get[int]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; elementList>
<org.jgrapht.alg.RankingPathElementList; isAlreadyImprovedByThisEdge[E, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<org.jgrapht.alg.RankingPathElementList; containsTargetPreviously[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<org.jgrapht.alg.RankingPathElementList; calculatePathWeight[org.jgrapht.alg.RankingPathElement<V,E>, E]; double; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<org.jgrapht.alg.AbstractPathElementList; get[int]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<org.jgrapht.alg.RankingPathElement; getWeight[]; double; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; yPathElement>
<java.util.ArrayList; add[int, org.jgrapht.alg.RankingPathElement<V,E>]; void; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<java.util.ArrayList; remove[int]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<org.jgrapht.alg.RankingPathElement; getWeight[]; double; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; yPathElement>
<org.jgrapht.alg.RankingPathElementList; isAlreadyAdded[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<java.util.ArrayList; add[int, org.jgrapht.alg.RankingPathElement<V,E>]; void; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<java.util.ArrayList; remove[int]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<org.jgrapht.alg.RankingPathElement; getWeight[]; double; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; yPathElement>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this>
<java.util.ArrayList; add[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<org.jgrapht.Graph; getEdgeWeight[E]; double; org.jgrapht.alg.RankingPathElementList; calculatePathWeight[org.jgrapht.alg.RankingPathElement<V,E>, E]; double; null; this.graph>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.RankingPathElementList; calculatePathWeight[org.jgrapht.alg.RankingPathElement<V,E>, E]; double; null; pathElement>
<org.jgrapht.alg.RankingPathElement; getWeight[]; double; org.jgrapht.alg.RankingPathElementList; calculatePathWeight[org.jgrapht.alg.RankingPathElement<V,E>, E]; double; null; pathElement>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.RankingPathElementList; containsTargetPreviously[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; tempPathElement>
<org.jgrapht.alg.AbstractPathElement; getVertex[]; V; org.jgrapht.alg.RankingPathElementList; containsTargetPreviously[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; tempPathElement>
<org.jgrapht.alg.RankingPathElement; getPrevPathElement[]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; containsTargetPreviously[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; tempPathElement>
<org.jgrapht.alg.AbstractPathElementList; size[]; int; org.jgrapht.alg.RankingPathElementList; isAlreadyAdded[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; this>
<org.jgrapht.alg.AbstractPathElementList; get[int]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; isAlreadyAdded[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; this>
<org.jgrapht.alg.RankingPathElementList; isDifferent[org.jgrapht.alg.RankingPathElement<V,E>, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; org.jgrapht.alg.RankingPathElementList; isAlreadyAdded[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; this>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.RankingPathElementList; isAlreadyImprovedByThisEdge[E, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; pathElementToTest>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.RankingPathElementList; isAlreadyImprovedByThisEdge[E, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; pathElementToTest>
<org.jgrapht.alg.RankingPathElement; getPrevPathElement[]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; isAlreadyImprovedByThisEdge[E, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; pathElementToTest>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.RankingPathElementList; isDifferent[org.jgrapht.alg.RankingPathElement<V,E>, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; yPathElement>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.RankingPathElementList; isDifferent[org.jgrapht.alg.RankingPathElement<V,E>, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; pathElementToTest>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.RankingPathElementList; isDifferent[org.jgrapht.alg.RankingPathElement<V,E>, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; yPathElement>
<org.jgrapht.alg.AbstractPathElement; getPrevEdge[]; E; org.jgrapht.alg.RankingPathElementList; isDifferent[org.jgrapht.alg.RankingPathElement<V,E>, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; pathElementToTest>
<org.jgrapht.alg.RankingPathElement; getPrevPathElement[]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; isDifferent[org.jgrapht.alg.RankingPathElement<V,E>, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; yPathElement>
<org.jgrapht.alg.RankingPathElement; getPrevPathElement[]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; isDifferent[org.jgrapht.alg.RankingPathElement<V,E>, org.jgrapht.alg.RankingPathElement<V,E>]; boolean; null; pathElementToTest>
<java.util.List; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; getAllMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; candidates>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<V>; org.jgrapht.alg.BronKerboschCliqueFinder; getAllMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; graph>
<org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; org.jgrapht.alg.BronKerboschCliqueFinder; getAllMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; this>
<org.jgrapht.alg.BronKerboschCliqueFinder; getAllMaximalCliques[]; java.util.Collection<java.util.Set<V>>; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; this>
<java.util.Set; size[]; int; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; clique>
<java.util.Set; size[]; int; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; clique>
<java.util.Set; size[]; int; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; clique>
<java.util.Collection; add[java.util.Set<V>]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; biggest_cliques>
<org.jgrapht.alg.BronKerboschCliqueFinder; end[java.util.List<V>, java.util.List<V>]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; this>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; potential_clique>
<java.util.List; remove[java.lang.Object]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; candidates>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; graph>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; new_candidates>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; graph>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; new_already_found>
<java.util.List; isEmpty[]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; new_candidates>
<java.util.List; isEmpty[]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; new_already_found>
<java.util.Collection; add[java.util.Set<V>]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; cliques>
<org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; this>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; already_found>
<java.util.List; remove[java.lang.Object]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; potential_clique>
<org.jgrapht.Graph; containsEdge[V, V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; end[java.util.List<V>, java.util.List<V>]; boolean; null; graph>
<java.util.List; size[]; int; org.jgrapht.alg.BronKerboschCliqueFinder; end[java.util.List<V>, java.util.List<V>]; boolean; null; candidates>
<java.awt.Color; decode[java.lang.String]; java.awt.Color; org.jgrapht.alg.BronKerboschCliqueFinder; end[java.util.List<V>, java.util.List<V>]; boolean; null; Color>
<org.jgrapht.demo.JGraphAdapterDemo; init[]; void; org.jgrapht.demo.JGraphAdapterDemo; main[java.lang.String[]]; void; null; applet>
<java.awt.Container; add[java.awt.Component]; java.awt.Component; org.jgrapht.demo.JGraphAdapterDemo; main[java.lang.String[]]; void; null; frame.getContentPane()>
<javax.swing.JFrame; getContentPane[]; java.awt.Container; org.jgrapht.demo.JGraphAdapterDemo; main[java.lang.String[]]; void; add[java.awt.Component]; frame>
<java.awt.Frame; setTitle[java.lang.String]; void; org.jgrapht.demo.JGraphAdapterDemo; main[java.lang.String[]]; void; null; frame>
<javax.swing.JFrame; setDefaultCloseOperation[int]; void; org.jgrapht.demo.JGraphAdapterDemo; main[java.lang.String[]]; void; null; frame>
<java.awt.Window; pack[]; void; org.jgrapht.demo.JGraphAdapterDemo; main[java.lang.String[]]; void; null; frame>
<java.awt.Window; setVisible[boolean]; void; org.jgrapht.demo.JGraphAdapterDemo; main[java.lang.String[]]; void; null; frame>
<org.jgrapht.demo.JGraphAdapterDemo; adjustDisplaySettings[org.jgrapht.demo.JGraph]; void; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; this>
<java.awt.Container; add[java.awt.Component]; java.awt.Component; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; getContentPane()>
<javax.swing.JApplet; getContentPane[]; java.awt.Container; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; add[java.awt.Component]; this>
<java.applet.Applet; resize[java.awt.Dimension]; void; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; this>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; g>
<org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; this>
<org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; this>
<org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; this>
<org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; org.jgrapht.demo.JGraphAdapterDemo; init[]; void; null; this>
<not found; setPreferredSize[]; not found; org.jgrapht.demo.JGraphAdapterDemo; adjustDisplaySettings[org.jgrapht.demo.JGraph]; void; null; jg>
<java.applet.Applet; getParameter[java.lang.String]; java.lang.String; org.jgrapht.demo.JGraphAdapterDemo; adjustDisplaySettings[org.jgrapht.demo.JGraph]; void; null; this>
<java.awt.Color; decode[java.lang.String]; java.awt.Color; org.jgrapht.demo.JGraphAdapterDemo; adjustDisplaySettings[org.jgrapht.demo.JGraph]; void; null; Color>
<not found; setBackground[]; not found; org.jgrapht.demo.JGraphAdapterDemo; adjustDisplaySettings[org.jgrapht.demo.JGraph]; void; null; jg>
<org.jgrapht.ext.JGraphModelAdapter; getVertexCell[java.lang.Object]; org.jgrapht.ext.DefaultGraphCell; org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; null; jgAdapter>
<not found; getAttributes[]; not found; org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; null; cell>
<not found; getBounds[]; not found; org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; null; GraphConstants>
<java.awt.geom.RectangularShape; getWidth[]; double; org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; null; bounds>
<java.awt.geom.RectangularShape; getHeight[]; double; org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; null; bounds>
<not found; setBounds[]; not found; org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; null; GraphConstants>
<not found; put[]; not found; org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; null; cellAttr>
<not found; edit[]; not found; org.jgrapht.demo.JGraphAdapterDemo; positionVertexAt[java.lang.Object, int, int]; void; null; jgAdapter>
<java.lang.System; currentTimeMillis[]; long; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; System>
<org.jgrapht.demo.PerformanceDemo; reportPerformanceFor[java.lang.String, long]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; this>
<org.jgrapht.Graph; addVertex[java.lang.Object]; boolean; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; g>
<java.io.PrintStream; println[java.lang.String]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; System.out>
<org.jgrapht.Graph; addVertex[java.lang.Object]; boolean; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; g>
<org.jgrapht.Graph; addEdge[java.lang.Object, java.lang.Object]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; g>
<org.jgrapht.demo.PerformanceDemo; reportPerformanceFor[java.lang.String, long]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; this>
<java.lang.System; currentTimeMillis[]; long; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; System>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; i>
<java.util.Iterator; next[]; java.lang.Object; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; i>
<org.jgrapht.demo.PerformanceDemo; reportPerformanceFor[java.lang.String, long]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; this>
<java.lang.System; currentTimeMillis[]; long; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; System>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; i>
<java.util.Iterator; next[]; java.lang.Object; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; i>
<org.jgrapht.demo.PerformanceDemo; reportPerformanceFor[java.lang.String, long]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; this>
<java.io.PrintStream; println[java.lang.String]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; System.out>
<java.io.PrintStream; print[java.lang.String]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; System.out>
<java.io.InputStream; read[]; int; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; System.in>
<java.lang.Throwable; printStackTrace[]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; e>
<java.io.PrintStream; println[java.lang.String]; void; org.jgrapht.demo.PerformanceDemo; main[java.lang.String[]]; void; null; System.out>
<java.lang.System; currentTimeMillis[]; long; org.jgrapht.demo.PerformanceDemo; reportPerformanceFor[java.lang.String, long]; void; null; System>
<org.jgrapht.demo.PerformanceDemo; usedMemory[]; long; org.jgrapht.demo.PerformanceDemo; reportPerformanceFor[java.lang.String, long]; void; null; this>
<java.lang.Math; round[double]; long; org.jgrapht.demo.PerformanceDemo; reportPerformanceFor[java.lang.String, long]; void; null; Math>
<java.io.PrintStream; println[java.lang.String]; void; org.jgrapht.demo.PerformanceDemo; reportPerformanceFor[java.lang.String, long]; void; null; System.out>
<java.lang.Runtime; getRuntime[]; java.lang.Runtime; org.jgrapht.demo.PerformanceDemo; usedMemory[]; long; null; Runtime>
<java.lang.Runtime; totalMemory[]; long; org.jgrapht.demo.PerformanceDemo; usedMemory[]; long; null; rt>
<java.lang.Runtime; freeMemory[]; long; org.jgrapht.demo.PerformanceDemo; usedMemory[]; long; null; rt>
<org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; org.jgrapht.demo.HelloJGraphT; main[java.lang.String[]]; void; null; this>
<java.io.PrintStream; println[java.lang.String]; void; org.jgrapht.demo.HelloJGraphT; main[java.lang.String[]]; void; null; System.out>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.demo.HelloJGraphT; main[java.lang.String[]]; void; null; stringGraph>
<org.jgrapht.demo.HelloJGraphT; createHrefGraph[]; org.jgrapht.DirectedGraph<java.net.URL,org.jgrapht.graph.DefaultEdge>; org.jgrapht.demo.HelloJGraphT; main[java.lang.String[]]; void; null; this>
<java.io.PrintStream; println[java.lang.String]; void; org.jgrapht.demo.HelloJGraphT; main[java.lang.String[]]; void; null; System.out>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.demo.HelloJGraphT; main[java.lang.String[]]; void; null; hrefGraph>
<org.jgrapht.Graph; addVertex[java.net.URL]; boolean; org.jgrapht.demo.HelloJGraphT; createHrefGraph[]; org.jgrapht.DirectedGraph<java.net.URL,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addVertex[java.net.URL]; boolean; org.jgrapht.demo.HelloJGraphT; createHrefGraph[]; org.jgrapht.DirectedGraph<java.net.URL,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addVertex[java.net.URL]; boolean; org.jgrapht.demo.HelloJGraphT; createHrefGraph[]; org.jgrapht.DirectedGraph<java.net.URL,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.net.URL, java.net.URL]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.HelloJGraphT; createHrefGraph[]; org.jgrapht.DirectedGraph<java.net.URL,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.net.URL, java.net.URL]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.HelloJGraphT; createHrefGraph[]; org.jgrapht.DirectedGraph<java.net.URL,org.jgrapht.graph.DefaultEdge>; null; g>
<java.lang.Throwable; printStackTrace[]; void; org.jgrapht.demo.HelloJGraphT; createHrefGraph[]; org.jgrapht.DirectedGraph<java.net.URL,org.jgrapht.graph.DefaultEdge>; null; e>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addVertex[java.lang.String]; boolean; org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.Graph; addEdge[java.lang.String, java.lang.String]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.HelloJGraphT; createStringGraph[]; org.jgrapht.UndirectedGraph<java.lang.String,org.jgrapht.graph.DefaultEdge>; null; g>
<org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<java.lang.Object,org.jgrapht.graph.DefaultEdge>, org.jgrapht.VertexFactory<java.lang.Object>, java.util.Map<java.lang.String,java.lang.Object>]; void; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; completeGenerator>
<java.util.Set; addAll[java.util.Collection<? extends java.lang.Object>]; boolean; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; vertices>
<org.jgrapht.Graph; vertexSet[]; java.util.Set<java.lang.Object>; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; completeGraph>
<org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; this>
<java.util.Iterator; hasNext[]; boolean; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; iter>
<java.util.Iterator; next[]; java.lang.Object; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; iter>
<java.io.PrintStream; println[java.lang.String]; void; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; System.out>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; vertex>
<java.lang.Object; toString[]; java.lang.String; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; completeGraph.edgesOf(vertex)>
<org.jgrapht.Graph; edgesOf[java.lang.Object]; java.util.Set<org.jgrapht.graph.DefaultEdge>; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; toString[]; completeGraph>
<org.jgrapht.Graph; edgesOf[java.lang.Object]; java.util.Set<org.jgrapht.graph.DefaultEdge>; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; completeGraph>
<org.jgrapht.Graph; addVertex[java.lang.Object]; boolean; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; completeGraph>
<org.jgrapht.Graph; getEdgeSource[org.jgrapht.graph.DefaultEdge]; java.lang.Object; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; completeGraph>
<org.jgrapht.Graph; getEdgeTarget[org.jgrapht.graph.DefaultEdge]; java.lang.Object; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; completeGraph>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; sourceVertex>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; targetVertex>
<org.jgrapht.Graph; addEdge[java.lang.Object, java.lang.Object]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; completeGraph>
<java.lang.Object; equals[java.lang.Object]; boolean; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; sourceVertex>
<org.jgrapht.Graph; addEdge[java.lang.Object, java.lang.Object]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; completeGraph>
<org.jgrapht.Graph; addEdge[java.lang.Object, java.lang.Object]; org.jgrapht.graph.DefaultEdge; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; completeGraph>
<org.jgrapht.Graph; removeVertex[java.lang.Object]; boolean; org.jgrapht.demo.CompleteGraphDemo; replaceVertex[java.lang.Object, java.lang.Object]; boolean; null; completeGraph>


Calls That Belongs To JCF (642)

<java.util.List; add[V]; boolean; org.jgrapht.Graphs; neighborListOf[org.jgrapht.Graph<V,E>, V]; java.util.List<V>; null; neighbors>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; predecessorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; null; predecessors>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; successorListOf[org.jgrapht.DirectedGraph<V,E>, V]; java.util.List<V>; null; successors>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; getPathVertexList[org.jgrapht.GraphPath<V,E>]; java.util.List<V>; null; list>
<java.util.List; add[V]; boolean; org.jgrapht.Graphs; getPathVertexList[org.jgrapht.GraphPath<V,E>]; java.util.List<V>; null; list>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target.vertexSet()>
<java.util.Collection; add[V]; boolean; java.lang.Object; createVertex[]; V; null; rim>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.WheelGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.util.Set; add[V]; boolean; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; a>
<java.util.Set; add[V]; boolean; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; b>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; a>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteBipartiteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; b>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.generate.RingGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; privateMap>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.generate.RingGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; privateMap>
<java.util.Map; put[java.lang.Integer, V]; V; org.jgrapht.generate.RandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; orderToVertexMap>
<java.util.Map; get[java.lang.Object]; VV; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; orderToVertexMap>
<java.util.Map; get[java.lang.Object]; VV; org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory; createEdges[org.jgrapht.Graph<VV,EE>, java.util.Map<java.lang.Integer,VV>, int, java.util.Random]; void; null; orderToVertexMap>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target.vertexSet()>
<java.util.List; size[]; int; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexList>
<java.util.List; get[int]; java.lang.Integer; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; degrees>
<java.util.List; set[int, java.lang.Integer]; java.lang.Integer; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; degrees>
<java.util.List; get[int]; java.lang.Integer; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; degrees>
<java.util.List; get[int]; V; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; addEdge[V, V]; vertexList>
<java.util.List; get[int]; V; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; addEdge[V, V]; vertexList>
<java.util.List; add[V]; boolean; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertexList>
<java.util.List; add[java.lang.Integer]; boolean; org.jgrapht.generate.ScaleFreeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; degrees>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.LinearGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.LinearGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertices>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.util.LinkedList; get[int]; V; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; addEdge[V, V]; vertices>
<java.util.LinkedList; get[int]; V; org.jgrapht.generate.HyperCubeGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; vertices>
<java.util.List; add[java.lang.String]; boolean; org.jgrapht.experimental.GraphReader; split[java.lang.String]; java.util.List<java.lang.String>; null; l>
<java.util.List; isEmpty[]; boolean; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; null; cols>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; equals[java.lang.Object]; cols>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; skipComments[]; java.util.List<java.lang.String>; startsWith[java.lang.String]; cols>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; readNodeCount[]; int; equals[java.lang.Object]; cols>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; readNodeCount[]; int; null; cols>
<java.util.Map; put[java.lang.String, V]; V; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; equals[java.lang.Object]; cols>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; addEdge[V, V]; resultMap>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; cols>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; resultMap>
<java.util.List; get[int]; java.lang.String; org.jgrapht.experimental.GraphReader; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; cols>
<java.util.List; size[]; int; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; size[]; int; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; toString[]; jgtNodes>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.List; get[int]; V; org.jgrapht.experimental.touchgraph.TouchgraphConverter; convertToTouchGraph[org.jgrapht.Graph<V,E>, org.jgrapht.experimental.touchgraph.TGPanel, boolean]; org.jgrapht.experimental.touchgraph.Node; null; jgtNodes>
<java.util.HashMap; values[]; java.util.Collection<java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; map>
<java.util.ArrayList; add[org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; arrayList>
<java.util.ArrayList; size[]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; arrayList>
<java.util.ArrayList; toArray[org.jgrapht.experimental.equivalence.EquivalenceSet[]]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupOrderedArray[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; org.jgrapht.experimental.equivalence.EquivalenceSet[]; null; arrayList>
<java.util.Collection; size[]; int; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; elements>
<java.util.HashMap; get[java.lang.Object]; java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; equalityGroupMap>
<java.util.List; add[org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; list>
<java.util.HashMap; put[java.lang.Integer, java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>]; java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; equalityGroupMap>
<java.util.List; add[org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSetCreator; createEqualityGroupMap[java.util.Collection<EE>, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super EE,? super CC>, CC]; java.util.HashMap<java.lang.Integer,java.util.List<org.jgrapht.experimental.equivalence.EquivalenceSet<? super EE,? super CC>>>; null; list>
<java.util.Set; add[E]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSet; EquivalenceSet[E, org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>, C]; void; null; this.elementsSet>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.experimental.equivalence.EquivalenceSet; getRepresentative[]; E; next[]; elementsSet>
<java.util.Set; size[]; int; org.jgrapht.experimental.equivalence.EquivalenceSet; size[]; int; null; elementsSet>
<java.util.Set; add[E]; boolean; org.jgrapht.experimental.equivalence.EquivalenceSet; add[E]; void; null; this.elementsSet>
<java.util.Set; toArray[]; java.lang.Object[]; org.jgrapht.experimental.equivalence.EquivalenceSet; toArray[]; java.lang.Object[]; null; this.elementsSet>
<java.util.List; add[org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; EquivalenceComparatorChainBase[org.jgrapht.experimental.equivalence.EquivalenceComparator<E,C>]; void; null; this.chain>
<java.util.List; add[org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>]; boolean; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; appendComparator[org.jgrapht.experimental.equivalence.EquivalenceComparator]; void; null; this.chain>
<java.util.List; listIterator[]; java.util.ListIterator<org.jgrapht.experimental.equivalence.EquivalenceComparator<? super E,? super C>>; org.jgrapht.experimental.equivalence.EquivalenceComparatorChainBase; equivalenceHashcode[E, C]; int; null; this.chain>
<java.util.Map; put[java.lang.String, java.lang.Object[]]; java.lang.Object[]; org.jgrapht.experimental.PartiteRandomGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,java.lang.Object[]>]; void; null; resultMap>
<java.util.List; size[]; int; org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; null; adjVertices>
<java.util.List; get[int]; V; org.jgrapht.experimental.GraphSquare; addEdgesStartingAt[org.jgrapht.Graph<V,E>, V, V, boolean]; void; null; adjVertices>
<java.util.List; size[]; int; org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; null; adjVertices>
<java.util.List; get[int]; V; org.jgrapht.experimental.GraphSquare; addSquareEdges[org.jgrapht.Graph<V,E>, boolean]; void; null; adjVertices>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsF[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; df>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; dfsB[V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; void; null; db>
<java.util.Set; size[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; df>
<java.util.Set; size[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; db>
<java.util.Set; add[java.lang.Integer]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; availableTopoIndices>
<java.util.Set; add[java.lang.Integer]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph; reorder[java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited]; void; null; availableTopoIndices>
<java.util.Map; put[java.lang.Integer, V]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; putVertex[java.lang.Integer, V]; void; null; topoToVertex>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; putVertex[java.lang.Integer, V]; void; null; vertexToTopo>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; getVertex[java.lang.Integer]; V; null; topoToVertex>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; getTopologicalIndex[V]; java.lang.Integer; null; vertexToTopo>
<java.util.Map; remove[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; removeVertex[V]; java.lang.Integer; null; vertexToTopo>
<java.util.Map; remove[java.lang.Object]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; removeVertex[V]; java.lang.Integer; null; topoToVertex>
<java.util.Map; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; removeAllVertices[]; void; null; vertexToTopo>
<java.util.Map; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexBiMap; removeAllVertices[]; void; null; topoToVertex>
<java.util.List; size[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; topoToVertex>
<java.util.List; add[V]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; topoToVertex>
<java.util.List; set[int, V]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; topoToVertex>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; putVertex[java.lang.Integer, V]; void; null; vertexToTopo>
<java.util.List; get[int]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; getVertex[java.lang.Integer]; V; null; topoToVertex>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; getTopologicalIndex[V]; java.lang.Integer; null; vertexToTopo>
<java.util.Map; remove[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeVertex[V]; java.lang.Integer; null; vertexToTopo>
<java.util.List; set[int, V]; V; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeVertex[V]; java.lang.Integer; null; topoToVertex>
<java.util.Map; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeAllVertices[]; void; null; vertexToTopo>
<java.util.List; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoVertexMap; removeAllVertices[]; void; null; topoToVertex>
<java.util.List; size[]; int; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; getInstance[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited; null; visited>
<java.util.List; add[java.lang.Boolean]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; getInstance[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited; null; visited>
<java.util.List; set[int, java.lang.Boolean]; java.lang.Boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; setVisited[int]; void; null; visited>
<java.util.List; get[int]; java.lang.Boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; getVisited[int]; boolean; null; visited>
<java.util.List; set[int, java.lang.Boolean]; java.lang.Boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedArrayListImpl; clearVisited[int]; void; null; visited>
<java.util.Set; clear[]; void; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedHashSetImpl; getInstance[org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region]; org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited; null; visited>
<java.util.Set; add[java.lang.Integer]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedHashSetImpl; setVisited[int]; void; null; visited>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedHashSetImpl; getVisited[int]; boolean; null; visited>
<java.util.Set; size[]; int; org.jgrapht.experimental.permutation.CollectionPermutationIter; CollectionPermutationIter[java.util.Set<E>]; void; null; objectsSet>
<java.util.List; size[]; int; org.jgrapht.experimental.permutation.CollectionPermutationIter; CollectionPermutationIter[java.util.List<E>]; void; null; objectsArray>
<java.util.ArrayList; size[]; int; org.jgrapht.experimental.permutation.CollectionPermutationIter; applyPermutation[]; java.util.List<E>; null; output>
<java.util.ArrayList; set[int, E]; E; org.jgrapht.experimental.permutation.CollectionPermutationIter; applyPermutation[]; java.util.List<E>; null; output>
<java.util.List; get[int]; E; org.jgrapht.experimental.permutation.CollectionPermutationIter; applyPermutation[]; java.util.List<E>; null; this.sourceArray>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isEmpty[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isComplete[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isComplete[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; next[]; g.vertexSet()>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; known>
<java.util.AbstractCollection; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.LinkedList; removeFirst[]; V; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; Graphs.neighborListOf(g,v)>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; known>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; known>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; known>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; next[]; unknown>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; unknown>
<java.util.AbstractCollection; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; next[]; unknown>
<java.util.LinkedList; removeFirst[]; V; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; unknown>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; Graphs.neighborListOf(g,v)>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; unknown>
<java.util.LinkedList; add[V]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; queue>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; odd>
<java.util.Set; add[V]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; odd>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; odd>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; odd>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; vertexSet>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; mapVertexToOrder>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; edgeSet>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; mapVertexToOrder>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; intValue[]; mapVertexToOrder>
<java.util.Set; add[org.jgrapht.experimental.isomorphism.GraphOrdering<V,E>.LabelsEdge]; boolean; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; this.labelsEdgesSet>
<java.util.Set; add[org.jgrapht.experimental.isomorphism.GraphOrdering<V,E>.LabelsEdge]; boolean; org.jgrapht.experimental.isomorphism.GraphOrdering; init[org.jgrapht.Graph<V,E>, java.util.Set<V>, java.util.Set<E>]; void; null; this.labelsEdgesSet>
<java.util.Set; equals[java.lang.Object]; boolean; org.jgrapht.experimental.isomorphism.GraphOrdering; equalsByEdgeOrder[org.jgrapht.experimental.isomorphism.GraphOrdering]; boolean; null; this.getLabelsEdgesSet()>
<java.util.Map; size[]; int; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; this.mapVertexToOrder>
<java.util.Map; keySet[]; java.util.Set<V>; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; this.mapVertexToOrder>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.isomorphism.GraphOrdering; toString[]; java.lang.String; null; this.mapVertexToOrder>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet1>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet2>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet1>
<java.util.Set; clear[]; void; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet1>
<java.util.Set; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet1>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.EquivalenceIsomorphismInspector; createPermutationIterator[java.util.Set<V>, java.util.Set<V>]; org.jgrapht.experimental.permutation.CollectionPermutationIter<V>; null; vertexSet2>
<java.util.List; size[]; int; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; vertexList1>
<java.util.List; get[int]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; this.vertexList1>
<java.util.List; get[int]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; this.vertexList2>
<java.util.Map; put[V, V]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; g1ToG2>
<java.util.Map; put[V, V]; V; org.jgrapht.experimental.isomorphism.IsomorphismRelation; initGraphMapping[]; void; null; g2ToG1>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; vertexSet1>
<java.util.Set; size[]; int; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; vertexSet2>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; vertexSet2>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.isomorphism.PermutationIsomorphismInspector; areVertexSetsOfTheSameEqualityGroup[java.util.Set<V>, java.util.Set<V>]; boolean; null; vertexSet1>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[degree[i]]>
<java.util.List; size[]; int; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[i]>
<java.util.List; size[]; int; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[i]>
<java.util.List; get[int]; java.lang.Object; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[i]>
<java.util.List; remove[int]; java.lang.Object; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[i]>
<java.util.List; remove[java.lang.Object]; boolean; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[degree[nb]]>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.experimental.alg.color.GreedyColoring; smallestDegreeLastOrder[]; int[]; null; buckets[degree[nb]]>
<java.util.List; size[]; int; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; getResult[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; _vertices>
<java.util.Map; put[V, java.lang.Object]; java.lang.Object; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; getResult[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; additionalData>
<java.util.List; get[int]; V; org.jgrapht.experimental.alg.color.BrownBacktrackColoring; getResult[java.util.Map<V,java.lang.Object>]; java.lang.Integer; null; _vertices>
<java.util.Set; size[]; int; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; g.vertexSet()>
<java.util.List; add[V]; boolean; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; _vertices>
<java.util.Set; size[]; int; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; g.edgesOf(vertex)>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; _vertexToPos>
<java.util.List; get[int]; V; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; _vertices>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; _vertexToPos>
<java.util.List; size[]; int; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; sourceVertices>
<java.util.List; size[]; int; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; destVertices>
<java.util.List; get[int]; java.lang.Object; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; addEdge[java.lang.Object, java.lang.Object]; sourceVertices>
<java.util.List; get[int]; java.lang.Object; org.jgrapht.experimental.RandomGraphHelper; addEdges[org.jgrapht.Graph, java.util.List, java.util.List, int]; void; null; destVertices>
<java.util.Stack; push[org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.util.Stack; empty[]; boolean; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.util.Stack; pop[]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.util.Stack; push[org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.util.Stack; push[org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; toString[]; java.lang.String; null; stack>
<java.util.List; add[org.jgrapht.util.FibonacciHeapNode<T>]; boolean; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<java.util.List; get[int]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<java.util.List; set[int, org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<java.util.List; set[int, org.jgrapht.util.FibonacciHeapNode<T>]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<java.util.List; get[int]; org.jgrapht.util.FibonacciHeapNode<T>; org.jgrapht.util.FibonacciHeap; consolidate[]; void; null; array>
<java.util.AbstractSet; equals[java.lang.Object]; boolean; org.jgrapht.util.ArrayUnenforcedSet; equals[java.lang.Object]; boolean; null; new SetForEquality()>
<java.util.AbstractSet; hashCode[]; int; org.jgrapht.util.ArrayUnenforcedSet; hashCode[]; int; null; new SetForEquality()>
<java.util.ArrayList; iterator[]; java.util.Iterator<E>; org.jgrapht.util.ArrayUnenforcedSet.SetForEquality; iterator[]; java.util.Iterator<E>; null; ArrayUnenforcedSet.this>
<java.util.ArrayList; size[]; int; org.jgrapht.util.ArrayUnenforcedSet.SetForEquality; size[]; int; null; ArrayUnenforcedSet.this>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; jGraphTGraph.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; jGraphTGraph.edgeSet()>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.ext.JGraphModelAdapter; handleJGraphRemovedVertex[org.jgrapht.ext.GraphCell]; void; null; jtIncidentEdges>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; ports>
<java.util.List; toArray[]; java.lang.Object[]; org.jgrapht.ext.JGraphModelAdapter; handleJGraphTRemoveVertex[java.lang.Object]; void; null; ports>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; filterEdges[java.lang.Object[]]; java.util.List<java.lang.Object>; null; jEdges>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; filterVertices[java.lang.Object[]]; java.util.List<java.lang.Object>; null; jVertices>
<java.util.List; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; filterVertices[java.lang.Object[]]; java.util.List<java.lang.Object>; null; jVertices>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleChangedEdges[java.util.List<java.lang.Object>]; void; null; jEdges>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedEdges[java.util.List<java.lang.Object>]; void; null; jEdges>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleInsertedVertices[java.util.List<java.lang.Object>]; void; null; jVertices>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedEdges[java.util.List<java.lang.Object>]; void; null; jEdges>
<java.util.List; iterator[]; java.util.Iterator<java.lang.Object>; org.jgrapht.ext.JGraphModelAdapter.JGraphListener; handleRemovedVertices[java.util.List<java.lang.Object>]; void; null; jVertices>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; jtElementsBeingAdded>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; jtElementsBeingRemoved>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; vertexAdded[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; jtElementsBeingAdded>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.JGraphTListener; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; jtElementsBeingRemoved>
<java.util.Set; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addEdge[V, V]; E; null; jtElementsBeingAdded>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addEdge[V, V]; E; null; jtElementsBeingAdded>
<java.util.Set; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addVertex[V]; void; null; jtElementsBeingAdded>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; addVertex[V]; void; null; jtElementsBeingAdded>
<java.util.Set; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeEdge[E]; void; null; jtElementsBeingRemoved>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeEdge[E]; void; null; jtElementsBeingRemoved>
<java.util.Set; add[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeVertex[V]; void; null; jtElementsBeingRemoved>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.ext.JGraphModelAdapter.ShieldedGraph; removeVertex[V]; void; null; jtElementsBeingRemoved>
<java.util.Map; clear[]; void; org.jgrapht.ext.IntegerEdgeNameProvider; clear[]; void; null; idMap>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.ext.IntegerEdgeNameProvider; getEdgeName[E]; java.lang.String; null; idMap>
<java.util.Map; put[E, java.lang.Integer]; java.lang.Integer; org.jgrapht.ext.IntegerEdgeNameProvider; getEdgeName[E]; java.lang.String; null; idMap>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; g.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; g.edgeSet()>
<java.util.Map; clear[]; void; org.jgrapht.ext.IntegerNameProvider; clear[]; void; null; idMap>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.ext.IntegerNameProvider; getVertexName[V]; java.lang.String; null; idMap>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.ext.IntegerNameProvider; getVertexName[V]; java.lang.String; null; idMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; counts>
<java.util.Map; put[java.lang.String, org.jgrapht.util.ModifiableInteger]; org.jgrapht.util.ModifiableInteger; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; counts>
<java.util.Map; entrySet[]; java.util.Set<java.util.Map.Entry<java.lang.String,org.jgrapht.util.ModifiableInteger>>; org.jgrapht.ext.MatrixExporter; exportAdjacencyMatrixVertex[java.io.PrintWriter, org.jgrapht.ext.VertexNameProvider<V>, V, java.util.List<V>]; void; null; counts>
<java.util.List; size[]; int; org.jgrapht.ext.MatrixExporter; exportLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; neighbors>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.ext.MatrixExporter; exportNormalizedLaplacianMatrix[java.io.Writer, org.jgrapht.UndirectedGraph<V,E>]; void; null; neighbors>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; TopologicalOrderIterator[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; void; null; dg.vertexSet()>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; TopologicalOrderIterator[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; void; null; queue>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; isConnectedComponentExhausted[]; boolean; null; queue>
<java.util.Queue; remove[]; V; org.jgrapht.traverse.TopologicalOrderIterator; provideNextVertex[]; V; null; queue>
<java.util.Map; get[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.traverse.TopologicalOrderIterator; decrementInDegree[V]; void; null; inDegreeMap>
<java.util.Queue; offer[V]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; decrementInDegree[V]; void; null; queue>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; dg.vertexSet()>
<java.util.Map; put[V, org.jgrapht.util.ModifiableInteger]; org.jgrapht.util.ModifiableInteger; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; inDegreeMap>
<java.util.Queue; offer[V]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; queue>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; queue>
<java.util.Queue; peek[]; V; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; queue>
<java.util.LinkedList; getFirst[]; T; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; element[]; T; null; this>
<java.util.LinkedList; add[T]; boolean; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; offer[T]; boolean; null; this>
<java.util.AbstractCollection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; peek[]; T; null; this>
<java.util.LinkedList; getFirst[]; T; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; peek[]; T; null; this>
<java.util.AbstractCollection; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; poll[]; T; null; this>
<java.util.LinkedList; removeFirst[]; T; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; poll[]; T; null; this>
<java.util.LinkedList; removeFirst[]; T; org.jgrapht.traverse.TopologicalOrderIterator.LinkedListQueue; remove[]; T; null; this>
<java.util.List; contains[java.lang.Object]; boolean; org.jgrapht.traverse.AbstractGraphIterator; addTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; add[org.jgrapht.event.TraversalListener<V,E>]; boolean; org.jgrapht.traverse.AbstractGraphIterator; addTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; size[]; int; org.jgrapht.traverse.AbstractGraphIterator; addTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; remove[java.lang.Object]; boolean; org.jgrapht.traverse.AbstractGraphIterator; removeTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; size[]; int; org.jgrapht.traverse.AbstractGraphIterator; removeTraversalListener[org.jgrapht.event.TraversalListener<V,E>]; void; null; traversalListeners>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireConnectedComponentFinished[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; null; traversalListeners>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireConnectedComponentStarted[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; null; traversalListeners>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireEdgeTraversed[org.jgrapht.event.EdgeTraversalEvent<V,E>]; void; null; traversalListeners>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireVertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; traversalListeners>
<java.util.List; get[int]; org.jgrapht.event.TraversalListener<V,E>; org.jgrapht.traverse.AbstractGraphIterator; fireVertexFinished[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; traversalListeners>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.DepthFirstIterator; isConnectedComponentExhausted[]; boolean; null; stack>
<java.util.Deque; getLast[]; java.lang.Object; org.jgrapht.traverse.DepthFirstIterator; isConnectedComponentExhausted[]; boolean; null; stack>
<java.util.Deque; removeLast[]; java.lang.Object; org.jgrapht.traverse.DepthFirstIterator; isConnectedComponentExhausted[]; boolean; null; stack>
<java.util.Deque; addLast[java.lang.Object]; void; org.jgrapht.traverse.DepthFirstIterator; encounterVertex[V, E]; void; null; stack>
<java.util.Deque; removeLastOccurrence[java.lang.Object]; boolean; org.jgrapht.traverse.DepthFirstIterator; encounterVertexAgain[V, E]; void; null; stack>
<java.util.Deque; addLast[java.lang.Object]; void; org.jgrapht.traverse.DepthFirstIterator; encounterVertexAgain[V, E]; void; null; stack>
<java.util.Deque; removeLast[]; java.lang.Object; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; stack>
<java.util.Deque; addLast[java.lang.Object]; void; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; stack>
<java.util.Deque; addLast[java.lang.Object]; void; org.jgrapht.traverse.DepthFirstIterator; provideNextVertex[]; V; null; stack>
<java.util.Deque; removeLast[]; java.lang.Object; org.jgrapht.traverse.DepthFirstIterator; recordFinish[]; void; null; stack>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.traverse.CrossComponentIterator; CrossComponentIterator[org.jgrapht.Graph<V,E>, V]; void; null; g.vertexSet()>
<java.util.Map; get[java.lang.Object]; D; org.jgrapht.traverse.CrossComponentIterator; getSeenData[V]; D; null; seen>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.traverse.CrossComponentIterator; isSeenVertex[java.lang.Object]; boolean; null; seen>
<java.util.Map; put[V, D]; D; org.jgrapht.traverse.CrossComponentIterator; putSeenData[V, D]; D; null; seen>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.traverse.BreadthFirstIterator; isConnectedComponentExhausted[]; boolean; null; queue>
<java.util.Deque; add[V]; boolean; org.jgrapht.traverse.BreadthFirstIterator; encounterVertex[V, E]; void; null; queue>
<java.util.Deque; removeFirst[]; V; org.jgrapht.traverse.BreadthFirstIterator; provideNextVertex[]; V; null; queue>
<java.util.Set; size[]; int; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; forwardList>
<java.util.Set; size[]; int; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; reverseList>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; list>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.AsUndirectedGraph; getAllEdges[V, V]; java.util.Set<E>; null; list>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskVertexSet; contains[java.lang.Object]; boolean; null; this.vertexSet>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.graph.MaskVertexSet.MaskVertexSetNextElementFunctor; MaskVertexSetNextElementFunctor[]; void; null; MaskVertexSet.this.vertexSet>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; baseEdges>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; edgeSet>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.Subgraph; getAllEdges[V, V]; java.util.Set<E>; null; edges>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.graph.Subgraph; getEdge[V, V]; E; null; edges>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.Subgraph; getEdge[V, V]; E; next[]; edges>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; edges>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V]; E; null; edgeSet>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.Subgraph; addEdge[V, V, E]; boolean; null; edgeSet>
<java.util.Set; add[V]; boolean; org.jgrapht.graph.Subgraph; addVertex[V]; boolean; null; vertexSet>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; containsEdge[E]; boolean; null; edgeSet>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; containsVertex[V]; boolean; null; vertexSet>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.Subgraph; edgesOf[V]; java.util.Set<E>; null; edges>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; removeEdge[E]; boolean; null; edgeSet>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; removeEdge[V, V]; E; null; edgeSet>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; removeVertex[V]; boolean; null; vertexSet>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; edgeSet>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; addEdgesUsingFilter[java.util.Set<E>, java.util.Set<E>]; void; null; filter>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.graph.Subgraph; addVerticesUsingFilter[java.util.Set<V>, java.util.Set<V>]; void; null; vertexSet>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.Subgraph; addVerticesUsingFilter[java.util.Set<V>, java.util.Set<V>]; void; null; filter>
<java.util.List; add[java.lang.String]; boolean; org.jgrapht.graph.AbstractGraph; toStringFromSets[java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean]; java.lang.String; null; renderedEdges>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskSubgraph; containsEdge[E]; boolean; null; edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.graph.MaskSubgraph; degreeOf[V]; int; null; edgesOf(vertex)>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.graph.MaskSubgraph; getEdge[V, V]; E; null; edges>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.MaskSubgraph; getEdge[V, V]; E; next[]; edges>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskSubgraph; getEdgeSource[E]; V; null; edgeSet()>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskSubgraph; getEdgeTarget[E]; V; null; edgeSet()>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskSubgraph; getEdgeWeight[E]; double; null; edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.graph.MaskSubgraph; inDegreeOf[V]; int; null; incomingEdgesOf(vertex)>
<java.util.Set; size[]; int; org.jgrapht.graph.MaskSubgraph; outDegreeOf[V]; int; null; outgoingEdgesOf(vertex)>
<java.util.Map; get[java.lang.Object]; V; org.jgrapht.graph.DefaultGraphMapping; getVertexCorrespondence[V, boolean]; V; getEdge[V, V]; graphMapping>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.MaskEdgeSet; contains[java.lang.Object]; boolean; null; this.edgeSet>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.MaskEdgeSet.MaskEdgeSetNextElementFunctor; MaskEdgeSetNextElementFunctor[]; void; null; MaskEdgeSet.this.edgeSet>
<java.util.Map; put[E, org.jgrapht.graph.IntrusiveEdge]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V]; E; null; edgeMap>
<java.util.Map; put[E, org.jgrapht.graph.IntrusiveEdge]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; addEdge[V, V, E]; boolean; null; edgeMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; getIntrusiveEdge[E]; org.jgrapht.graph.IntrusiveEdge; null; edgeMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; containsEdge[E]; boolean; null; edgeMap>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; null; specifics.getVertexSet()>
<java.util.Map; keySet[]; java.util.Set<E>; org.jgrapht.graph.AbstractBaseGraph; edgeSet[]; java.util.Set<E>; null; edgeMap>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; removeEdge[V, V]; E; null; edgeMap>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.graph.IntrusiveEdge; org.jgrapht.graph.AbstractBaseGraph; removeEdge[E]; boolean; null; edgeMap>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; removeVertex[V]; boolean; null; specifics.getVertexSet()>
<java.util.Set; add[EE]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; addIncomingEdge[EE]; void; null; incoming>
<java.util.Set; add[EE]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; addOutgoingEdge[EE]; void; null; outgoing>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; removeIncomingEdge[EE]; void; null; incoming>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer; removeOutgoingEdge[EE]; void; null; outgoing>
<java.util.Map; put[V, org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; addVertex[V]; void; null; vertexMapDirected>
<java.util.Map; keySet[]; java.util.Set<V>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getVertexSet[]; java.util.Set<V>; null; vertexMapDirected>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; ec.outgoing>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; edges>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdge[V, V]; E; null; ec.outgoing>
<java.util.ArrayList; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; inAndOut>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; inAndOut>
<java.util.ArrayList; get[int]; E; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; inAndOut>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; loops>
<java.util.ArrayList; remove[int]; E; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; inAndOut>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; edgesOf[V]; java.util.Set<E>; null; loops>
<java.util.Set; size[]; int; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; inDegreeOf[V]; int; null; getEdgeContainer(vertex).incoming>
<java.util.Set; size[]; int; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; outDegreeOf[V]; int; null; getEdgeContainer(vertex).outgoing>
<java.util.Map; get[java.lang.Object]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; null; vertexMapDirected>
<java.util.Map; put[V, org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.DirectedEdgeContainer<V,E>; null; vertexMapDirected>
<java.util.Set; add[EE]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer; addEdge[EE]; void; null; vertexEdges>
<java.util.Set; size[]; int; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer; edgeCount[]; int; null; vertexEdges>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer; removeEdge[EE]; void; null; vertexEdges>
<java.util.Map; put[V, org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; addVertex[V]; void; null; vertexMapUndirected>
<java.util.Map; keySet[]; java.util.Set<V>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getVertexSet[]; java.util.Set<V>; null; vertexMapUndirected>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; getEdgeContainer(sourceVertex).vertexEdges>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; edges>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; getEdgeContainer(sourceVertex).vertexEdges>
<java.util.Map; get[java.lang.Object]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; null; vertexMapUndirected>
<java.util.Map; put[V, org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdgeContainer[V]; org.jgrapht.graph.AbstractBaseGraph.UndirectedEdgeContainer<V,E>; null; vertexMapUndirected>
<java.util.Map; put[E, java.lang.Double]; java.lang.Double; org.jgrapht.graph.AsWeightedGraph; setEdgeWeight[E, double]; void; null; weightMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.graph.AsWeightedGraph; getEdgeWeight[E]; double; null; weightMap>
<java.util.Map; get[java.lang.Object]; java.lang.Double; org.jgrapht.graph.AsWeightedGraph; getEdgeWeight[E]; double; null; weightMap>
<java.util.Set; size[]; int; org.jgrapht.graph.DirectedGraphUnion; inDegreeOf[V]; int; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DirectedGraphUnion; incomingEdgesOf[V]; java.util.Set<E>; null; res>
<java.util.Set; size[]; int; org.jgrapht.graph.DirectedGraphUnion; outDegreeOf[V]; int; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.DirectedGraphUnion; outgoingEdgesOf[V]; java.util.Set<E>; null; res>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.DirectedSubgraph; incomingEdgesOf[V]; java.util.Set<E>; null; edges>
<java.util.Set; add[E]; boolean; org.jgrapht.graph.DirectedSubgraph; outgoingEdgesOf[V]; java.util.Set<E>; null; edges>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; getAllEdges[V, V]; java.util.Set<E>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; edgeSet[]; java.util.Set<E>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; edgeSet[]; java.util.Set<E>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends E>]; boolean; org.jgrapht.graph.GraphUnion; edgesOf[V]; java.util.Set<E>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.graph.GraphUnion; vertexSet[]; java.util.Set<V>; null; res>
<java.util.Set; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.graph.GraphUnion; vertexSet[]; java.util.Set<V>; null; res>
<java.util.ArrayList; remove[java.lang.Object]; boolean; org.jgrapht.graph.DefaultListenableGraph; removeGraphListener[org.jgrapht.event.GraphListener<V,E>]; void; null; graphListeners>
<java.util.ArrayList; remove[java.lang.Object]; boolean; org.jgrapht.graph.DefaultListenableGraph; removeVertexSetListener[org.jgrapht.event.VertexSetListener<V>]; void; null; vertexSetListeners>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireEdgeAdded[E]; void; null; graphListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.GraphListener<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireEdgeAdded[E]; void; null; graphListeners>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireEdgeRemoved[E]; void; null; graphListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.GraphListener<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireEdgeRemoved[E]; void; null; graphListeners>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; vertexSetListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.VertexSetListener<V>; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; vertexSetListeners>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; graphListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.GraphListener<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireVertexAdded[V]; void; null; graphListeners>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; vertexSetListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.VertexSetListener<V>; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; vertexSetListeners>
<java.util.ArrayList; size[]; int; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; graphListeners>
<java.util.ArrayList; get[int]; org.jgrapht.event.GraphListener<V,E>; org.jgrapht.graph.DefaultListenableGraph; fireVertexRemoved[V]; void; null; graphListeners>
<java.util.List; contains[java.lang.Object]; boolean; org.jgrapht.graph.DefaultListenableGraph; addToListenerList[java.util.List<L>, L]; void; null; list>
<java.util.List; add[L]; boolean; org.jgrapht.graph.DefaultListenableGraph; addToListenerList[java.util.List<L>, L]; void; null; list>
<java.util.Set; size[]; int; org.jgrapht.graph.UndirectedGraphUnion; degreeOf[V]; int; null; res>
<java.util.Set; size[]; int; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; sg.edgeSet()>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; next[]; sg.edgeSet()>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; cover>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; cover>
<java.util.Set; size[]; int; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; null; sg.edgeSet()>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; null; cover>
<java.util.Set; size[]; int; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network.vertexSet()>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; indexer>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; indexer>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes.get(i).outgoingArcs>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; nodes>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes.get(j).outgoingArcs>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; nodes>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; indexer>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; indexer>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; nodes>
<java.util.Map; put[E, java.lang.Double]; java.lang.Double; org.jgrapht.alg.EdmondsKarpMaximumFlow; calculateMaximumFlow[V, V]; void; null; maximumFlow>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.Queue; offer[java.lang.Integer]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; queue>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.Collection; size[]; int; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; queue>
<java.util.Queue; poll[]; java.lang.Integer; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; queue>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; nodes>
<java.util.Queue; add[java.lang.Integer]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; breadthFirstSearch[]; void; null; queue>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; augmentFlow[]; void; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; getCurrentSource[]; V; null; nodes>
<java.util.List; get[int]; org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Node; org.jgrapht.alg.EdmondsKarpMaximumFlow; getCurrentSink[]; V; null; nodes>
<java.util.Set; size[]; int; org.jgrapht.alg.KShortestPaths; KShortestPaths[org.jgrapht.Graph<V,E>, V, int]; void; null; graph.vertexSet()>
<java.util.List; add[org.jgrapht.GraphPath<V,E>]; boolean; org.jgrapht.alg.KShortestPaths; getPaths[V]; java.util.List<org.jgrapht.GraphPath<V,E>>; null; pathList>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.KShortestPaths; assertGetPaths[V]; void; null; this.graph.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.BellmanFordShortestPath; BellmanFordShortestPath[org.jgrapht.Graph<V,E>, V]; void; null; graph.vertexSet()>
<java.util.ArrayList; add[T]; boolean; org.jgrapht.alg.AbstractPathElementList; AbstractPathElementList[org.jgrapht.Graph<V,E>, int, T]; void; null; this.pathElements>
<java.util.ArrayList; addAll[java.util.Collection<? extends T>]; boolean; org.jgrapht.alg.AbstractPathElementList; AbstractPathElementList[org.jgrapht.alg.AbstractPathElementList<V,E,T>]; void; null; this.pathElements>
<java.util.ArrayList; get[int]; T; org.jgrapht.alg.AbstractPathElementList; get[int]; T; null; this.pathElements>
<java.util.ArrayList; size[]; int; org.jgrapht.alg.AbstractPathElementList; size[]; int; null; this.pathElements>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.alg.KShortestPathsIterator; hasNext[]; boolean; null; this.prevImprovedVertices>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.KShortestPathsIterator; next[]; java.util.Set<V>; null; this.prevImprovedVertices>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; getPathElements[V]; org.jgrapht.alg.RankingPathElementList<V,E>; null; this.seenDataContainer>
<java.util.Map; put[V, org.jgrapht.alg.RankingPathElementList<V,E>]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; addFirstPath[V, E]; void; null; this.seenDataContainer>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; createSeenData[V, E]; org.jgrapht.alg.RankingPathElementList<V,E>; null; this.prevSeenDataContainer>
<java.util.Map; put[V, org.jgrapht.alg.RankingPathElementList<V,E>]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; encounterStartVertex[]; void; null; this.seenDataContainer>
<java.util.Map; put[V, org.jgrapht.alg.RankingPathElementList<V,E>]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; encounterStartVertex[]; void; null; this.prevSeenDataContainer>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.KShortestPathsIterator; encounterStartVertex[]; void; null; this.prevImprovedVertices>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; null; improvedVertices>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; null; this.seenDataContainer>
<java.util.Map; put[V, org.jgrapht.alg.RankingPathElementList<V,E>]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; savePassData[java.util.Set<V>]; void; null; this.prevSeenDataContainer>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; tryToAddNewPaths[V, E]; boolean; null; this.seenDataContainer>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.RankingPathElementList<V,E>; org.jgrapht.alg.KShortestPathsIterator; tryToAddNewPaths[V, E]; boolean; null; this.prevSeenDataContainer>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; edgesOf(vertex)>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; this.seenDataContainer>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; improvedVertices>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.KShortestPathsIterator; updateOutgoingVertices[V, java.util.Set<V>]; void; null; improvedVertices>
<java.util.List; size[]; int; org.jgrapht.alg.ConnectivityInspector; isGraphConnected[]; boolean; null; lazyFindConnectedSets()>
<java.util.Map; get[java.lang.Object]; java.util.Set<V>; org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; null; vertexToConnectedSet>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; null; connectedSet>
<java.util.Map; put[V, java.util.Set<V>]; java.util.Set<V>; org.jgrapht.alg.ConnectivityInspector; connectedSetOf[V]; java.util.Set<V>; null; vertexToConnectedSet>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.ConnectivityInspector; pathExists[V, V]; boolean; null; sourceSet>
<java.util.Set; size[]; int; org.jgrapht.alg.ConnectivityInspector; lazyFindConnectedSets[]; java.util.List<java.util.Set<V>>; null; vertexSet>
<java.util.List; add[java.util.Set<V>]; boolean; org.jgrapht.alg.ConnectivityInspector.MyTraversalListener; connectedComponentFinished[org.jgrapht.event.ConnectedComponentTraversalEvent]; void; null; connectedSets>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.ConnectivityInspector.MyTraversalListener; vertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; currentConnectedSet>
<java.util.Map; put[V, java.util.Set<V>]; java.util.Set<V>; org.jgrapht.alg.ConnectivityInspector.MyTraversalListener; vertexTraversed[org.jgrapht.event.VertexTraversalEvent<V>]; void; null; vertexToConnectedSet>
<java.util.List; add[E]; boolean; org.jgrapht.alg.AbstractPathElement; createEdgeListPath[]; java.util.List<E>; null; path>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.Set; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g.edgeSet()>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; tour>
<java.util.Set; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g.vertexSet()>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; tour>
<java.util.List; get[int]; V; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; tour>
<java.util.List; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.List; get[int]; V; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.List; add[int, V]; void; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; tour>
<java.util.List; get[int]; V; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.List; remove[int]; V; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; vertices>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; next[]; graph.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.dfsTree.edgesOf(s)>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.cutpoints>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.cutpoints>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.cutpoints>
<java.util.Map; put[V, org.jgrapht.UndirectedGraph<V,E>]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; this.vertex2block>
<java.util.Set; iterator[]; java.util.Iterator<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; biconnectedSubgraphs>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; BlockCutpointGraph[org.jgrapht.UndirectedGraph<V,E>]; void; null; vertexSet()>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; getBlock[V]; org.jgrapht.UndirectedGraph<V,E>; null; this.graph.vertexSet()>
<java.util.Map; get[java.lang.Object]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.alg.BlockCutpointGraph; getBlock[V]; org.jgrapht.UndirectedGraph<V,E>; null; this.vertex2block>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; isCutpoint[V]; boolean; null; this.graph.vertexSet()>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph; isCutpoint[V]; boolean; null; this.cutpoints>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.cutpoints>
<java.util.Deque; removeLast[]; org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.stack>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.stack>
<java.util.Set; add[org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edgeComponent>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<java.util.Deque; removeLast[]; org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.stack>
<java.util.Set; add[org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; edgeComponent>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; vertexComponent>
<java.util.Map; put[V, org.jgrapht.UndirectedGraph<V,E>]; org.jgrapht.UndirectedGraph<V,E>; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; this.vertex2block>
<java.util.Set; add[org.jgrapht.UndirectedGraph<V,E>]; boolean; org.jgrapht.alg.BlockCutpointGraph; biconnectedComponentFinished[V, V]; void; null; getBiconnectedSubgraphs(vertex)>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this.graph.edgesOf(s)>
<java.util.Deque; add[org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this.stack>
<java.util.Deque; add[org.jgrapht.alg.BlockCutpointGraph<V,E>.BCGEdge]; boolean; org.jgrapht.alg.BlockCutpointGraph; dfsVisit[V, V]; int; null; this.stack>
<java.util.Map; get[java.lang.Object]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; getBiconnectedSubgraphs[V]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; null; this.vertex2biconnectedSubgraphs>
<java.util.Map; put[V, java.util.Set<org.jgrapht.UndirectedGraph<V,E>>]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BlockCutpointGraph; getBiconnectedSubgraphs[V]; java.util.Set<org.jgrapht.UndirectedGraph<V,E>>; null; this.vertex2biconnectedSubgraphs>
<java.util.Map; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.BlockCutpointGraph; getNumOrder[V]; int; null; this.vertex2numOrder>
<java.util.Map; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.alg.BlockCutpointGraph; setNumOrder[V, int]; void; null; this.vertex2numOrder>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BlockCutpointGraph.VertexComponentForbiddenFunction; isVertexMasked[V]; boolean; null; this.vertexComponent>
<java.util.Set; iterator[]; java.util.Iterator<org.jgrapht.UndirectedGraph<V,E>>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; this.blockCutpointGraph.vertexSet()>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; subgraph.edgeSet()>
<java.util.Set; add[java.util.Set<V>]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; biconnectedVertexComponents>
<java.util.Set; iterator[]; java.util.Iterator<java.util.Set<V>>; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; null; getBiconnectedVertexComponents()>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; null; vertexComponent>
<java.util.Set; add[java.util.Set<V>]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[V]; java.util.Set<java.util.Set<V>>; null; vertexComponents>
<java.util.Set; size[]; int; org.jgrapht.alg.BiconnectivityInspector; isBiconnected[]; boolean; null; this.blockCutpointGraph.vertexSet()>
<java.util.List; add[E]; boolean; org.jgrapht.alg.DijkstraShortestPath; createEdgeList[org.jgrapht.Graph<V,E>, org.jgrapht.traverse.ClosestFirstIterator<V,E>, V, V]; void; null; edgeList>
<java.util.Set; size[]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g.vertexSet()>
<java.util.HashMap; get[java.lang.Object]; java.lang.Integer; org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; null; indices>
<java.util.HashMap; put[V, java.lang.Integer]; java.lang.Integer; org.jgrapht.alg.FloydWarshallShortestPaths; index[V]; int; null; indices>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.NeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; removeNeighbor[V]; neighborMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; neighborMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; removeNeighbor[V]; neighborMap>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; neighborMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; neighborMap>
<java.util.Map; put[V, org.jgrapht.alg.NeighborIndex.Neighbors<V,E>]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; neighborMap>
<java.util.Map; keySet[]; java.util.Set<V>; org.jgrapht.alg.NeighborIndex; getNeighbors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; neighborCounts>
<java.util.Map; get[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; addNeighbor[V]; void; null; neighborCounts>
<java.util.Map; put[V, org.jgrapht.util.ModifiableInteger]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; addNeighbor[V]; void; null; neighborCounts>
<java.util.Map; get[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; removeNeighbor[V]; void; null; neighborCounts>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.util.ModifiableInteger; org.jgrapht.alg.NeighborIndex.Neighbors; removeNeighbor[V]; void; null; neighborCounts>
<java.util.Map; entrySet[]; java.util.Set<java.util.Map.Entry<V,org.jgrapht.util.ModifiableInteger>>; org.jgrapht.alg.NeighborIndex.Neighbors; getNeighborList[]; java.util.List<V>; null; neighborCounts>
<java.util.List; add[V]; boolean; org.jgrapht.alg.NeighborIndex.Neighbors; getNeighborList[]; java.util.List<V>; null; neighbors>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EulerianCircuit; isEulerian[org.jgrapht.UndirectedGraph<V,E>]; boolean; null; g.vertexSet()>
<java.util.List; add[V]; boolean; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; path>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; next[]; sg.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg.edgeSet()>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; path>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg.vertexSet()>
<java.util.List; add[int, V]; void; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; path>
<java.util.Set; size[]; int; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; sg.vertexSet()>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; sortedVertices>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; currentColor>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; currentColor>
<java.util.List; isEmpty[]; boolean; org.jgrapht.alg.BellmanFordIterator; hasNext[]; boolean; null; this.prevImprovedVertices>
<java.util.List; size[]; int; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this.prevImprovedVertices>
<java.util.List; get[int]; V; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; this.prevImprovedVertices>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; improvedVertices>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BellmanFordIterator; next[]; java.util.List<V>; null; improvedVertices>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.BellmanFordIterator; edgesOfIterator[V]; java.util.Iterator<E>; null; ((DirectedGraph<V,E>)this.graph).outgoingEdgesOf(vertex)>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.alg.BellmanFordIterator; edgesOfIterator[V]; java.util.Iterator<E>; null; this.graph.edgesOf(vertex)>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; getPrevSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this.prevVertexData>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; getSeenData[V]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this.vertexData>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.BellmanFordIterator; isSeenVertex[V]; boolean; null; this.vertexData>
<java.util.Map; put[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; putPrevSeenData[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this.prevVertexData>
<java.util.Map; put[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; org.jgrapht.alg.BellmanFordIterator; putSeenData[V, org.jgrapht.alg.BellmanFordPathElement<V,E>]; org.jgrapht.alg.BellmanFordPathElement<V,E>; null; this.vertexData>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BellmanFordIterator; encounterStartVertex[]; void; null; this.prevImprovedVertices>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; successorMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.DirectedNeighborIndex; edgeAdded[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; predecessorMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; successorMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; removeNeighbor[V]; successorMap>
<java.util.Map; containsKey[java.lang.Object]; boolean; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; null; predecessorMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; edgeRemoved[org.jgrapht.event.GraphEdgeChangeEvent<V,E>]; void; removeNeighbor[V]; predecessorMap>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; predecessorMap>
<java.util.Map; remove[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; vertexRemoved[org.jgrapht.event.GraphVertexChangeEvent<V>]; void; null; successorMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; predecessorMap>
<java.util.Map; put[V, org.jgrapht.alg.NeighborIndex.Neighbors<V,E>]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; getPredecessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; predecessorMap>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; successorMap>
<java.util.Map; put[V, org.jgrapht.alg.NeighborIndex.Neighbors<V,E>]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; org.jgrapht.alg.DirectedNeighborIndex; getSuccessors[V]; org.jgrapht.alg.NeighborIndex.Neighbors<V,E>; null; successorMap>
<java.util.Set; size[]; int; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; component>
<java.util.Set; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; set>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; next[]; component>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.CycleDetector; findCycles[]; java.util.Set<V>; null; set>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; cycleSet>
<java.util.List; indexOf[java.lang.Object]; int; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; path>
<java.util.List; size[]; int; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; path>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; cycleSet>
<java.util.List; get[int]; V; org.jgrapht.alg.CycleDetector.ProbeIterator; encounterVertexAgain[V, E]; void; null; path>
<java.util.List; size[]; int; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; path>
<java.util.List; get[int]; V; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; path>
<java.util.List; remove[int]; V; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; path>
<java.util.List; add[V]; boolean; org.jgrapht.alg.CycleDetector.ProbeIterator; provideNextVertex[]; V; null; path>
<java.util.List; size[]; int; org.jgrapht.alg.StrongConnectivityInspector; isStronglyConnected[]; boolean; null; stronglyConnectedSets()>
<java.util.Map; values[]; java.util.Collection<org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>>; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; vertexToVertexData>
<java.util.List; add[java.util.Set<V>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSets[]; java.util.List<java.util.Set<V>>; null; stronglyConnectedSets>
<java.util.List; size[]; int; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSubgraphs[]; java.util.List<org.jgrapht.graph.DirectedSubgraph<V,E>>; null; sets>
<java.util.List; add[org.jgrapht.graph.DirectedSubgraph<V,E>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; stronglyConnectedSubgraphs[]; java.util.List<org.jgrapht.graph.DirectedSubgraph<V,E>>; null; stronglyConnectedSubgraphs>
<java.util.Set; size[]; int; org.jgrapht.alg.StrongConnectivityInspector; createVertexData[]; void; null; graph.vertexSet()>
<java.util.Map; put[V, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>; org.jgrapht.alg.StrongConnectivityInspector; createVertexData[]; void; null; vertexToVertexData>
<java.util.Deque; add[org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<java.util.Collection; isEmpty[]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<java.util.Deque; removeLast[]; org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; vertices>
<java.util.Deque; add[org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<java.util.Map; get[java.lang.Object]; org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; vertexToVertexData>
<java.util.Deque; add[org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; boolean; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; stack>
<java.util.LinkedList; addFirst[org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>]; void; org.jgrapht.alg.StrongConnectivityInspector; dfsVisit[org.jgrapht.DirectedGraph<V,E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>]; void; null; orderedVertices>
<java.util.Map; values[]; java.util.Collection<org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>>; org.jgrapht.alg.StrongConnectivityInspector; resetVertexData[]; void; null; vertexToVertexData>
<java.util.Set; size[]; int; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; vertexSet>
<java.util.Set; clear[]; void; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; newEdgeTargets>
<java.util.Set; add[V]; boolean; org.jgrapht.alg.TransitiveClosure; closeSimpleDirectedGraph[org.jgrapht.graph.SimpleDirectedGraph<V,E>]; void; null; newEdgeTargets>
<java.util.ArrayList; size[]; int; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; this.pathElements>
<java.util.ArrayList; add[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; this.pathElements>
<java.util.ArrayList; isEmpty[]; boolean; org.jgrapht.alg.RankingPathElementList; RankingPathElementList[org.jgrapht.Graph<V,E>, int, org.jgrapht.alg.RankingPathElementList<V,E>, E]; void; null; this.pathElements>
<java.util.ArrayList; add[int, org.jgrapht.alg.RankingPathElement<V,E>]; void; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<java.util.ArrayList; remove[int]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<java.util.ArrayList; add[int, org.jgrapht.alg.RankingPathElement<V,E>]; void; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<java.util.ArrayList; remove[int]; org.jgrapht.alg.RankingPathElement<V,E>; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<java.util.ArrayList; add[org.jgrapht.alg.RankingPathElement<V,E>]; boolean; org.jgrapht.alg.RankingPathElementList; addPathElements[org.jgrapht.alg.RankingPathElementList<V,E>, E]; boolean; null; this.pathElements>
<java.util.List; addAll[java.util.Collection<? extends V>]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; getAllMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; candidates>
<java.util.Set; size[]; int; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; clique>
<java.util.Set; size[]; int; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; clique>
<java.util.Set; size[]; int; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; clique>
<java.util.Collection; add[java.util.Set<V>]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; getBiggestMaximalCliques[]; java.util.Collection<java.util.Set<V>>; null; biggest_cliques>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; potential_clique>
<java.util.List; remove[java.lang.Object]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; candidates>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; new_candidates>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; new_already_found>
<java.util.List; isEmpty[]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; new_candidates>
<java.util.List; isEmpty[]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; new_already_found>
<java.util.Collection; add[java.util.Set<V>]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; cliques>
<java.util.List; add[V]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; already_found>
<java.util.List; remove[java.lang.Object]; boolean; org.jgrapht.alg.BronKerboschCliqueFinder; findCliques[java.util.List<V>, java.util.List<V>, java.util.List<V>]; void; null; potential_clique>
<java.util.List; size[]; int; org.jgrapht.alg.BronKerboschCliqueFinder; end[java.util.List<V>, java.util.List<V>]; boolean; null; candidates>
<java.util.Set; addAll[java.util.Collection<? extends java.lang.Object>]; boolean; org.jgrapht.demo.CompleteGraphDemo; main[java.lang.String[]]; void; null; vertices>


Calls That Are Candidatas (41)

<java.util.Set; isEmpty[]; boolean; org.jgrapht.traverse.TopologicalOrderIterator; TopologicalOrderIterator[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; void; null; dg.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.traverse.TopologicalOrderIterator; initialize[org.jgrapht.DirectedGraph<V,E>, java.util.Queue<V>, java.util.Map<V,org.jgrapht.util.ModifiableInteger>]; V; null; dg.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; jGraphTGraph.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.ext.JGraphModelAdapter; JGraphModelAdapter[org.jgrapht.Graph<V,E>, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.AttributeMap, org.jgrapht.ext.JGraphModelAdapter.CellFactory<V,E>]; void; null; jGraphTGraph.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; inDegreeOf[V]; int; null; getEdgeContainer(vertex).incoming>
<java.util.Set; size[]; int; org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics; outDegreeOf[V]; int; null; getEdgeContainer(vertex).outgoing>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getAllEdges[V, V]; java.util.Set<E>; null; getEdgeContainer(sourceVertex).vertexEdges>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics; getEdge[V, V]; E; null; getEdgeContainer(sourceVertex).vertexEdges>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.experimental.GraphTests; isEmpty[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isComplete[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isComplete[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isConnected[org.jgrapht.Graph<V,E>]; boolean; null; Graphs.neighborListOf(g,v)>
<java.util.Set; iterator[]; java.util.Iterator<E>; org.jgrapht.ext.VisioExporter; export[java.io.OutputStream, org.jgrapht.Graph<V,E>]; void; null; g.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isTree[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; g.edgeSet()>
<java.util.List; iterator[]; java.util.Iterator<V>; org.jgrapht.experimental.GraphTests; isBipartite[org.jgrapht.Graph<V,E>]; boolean; null; Graphs.neighborListOf(g,v)>
<java.util.Set; size[]; int; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; g.edgesOf(vertex)>
<java.util.Set; size[]; int; org.jgrapht.experimental.alg.IntArrayGraphAlgorithm; IntArrayGraphAlgorithm[org.jgrapht.Graph<V,E>]; void; null; g.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.StarGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.generate.CompleteGraphGenerator; generateGraph[org.jgrapht.Graph<V,E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String,V>]; void; null; target.vertexSet()>
<java.util.Set; isEmpty[]; boolean; org.jgrapht.alg.BiconnectivityInspector; getBiconnectedVertexComponents[]; java.util.Set<java.util.Set<V>>; null; subgraph.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.FloydWarshallShortestPaths; FloydWarshallShortestPaths[org.jgrapht.Graph<V,E>]; void; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.VertexCovers; find2ApproximationCover[org.jgrapht.Graph<V,E>]; java.util.Set<V>; null; sg.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.VertexCovers; findGreedyCover[org.jgrapht.UndirectedGraph<V,E>]; java.util.Set<V>; null; sg.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network.vertexSet()>
<java.util.Set; iterator[]; java.util.Iterator<V>; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; network.vertexSet()>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes.get(i).outgoingArcs>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes.get(j).outgoingArcs>
<java.util.Set; size[]; int; org.jgrapht.alg.EulerianCircuit; getEulerianCircuitVertices[org.jgrapht.UndirectedGraph<V,E>]; java.util.List<V>; null; sg.edgeSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.KShortestPaths; KShortestPaths[org.jgrapht.Graph<V,E>, V, int]; void; null; graph.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.ChromaticNumber; findGreedyChromaticNumber[org.jgrapht.UndirectedGraph<V,E>]; int; null; sg.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.StrongConnectivityInspector; createVertexData[]; void; null; graph.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.BellmanFordShortestPath; BellmanFordShortestPath[org.jgrapht.Graph<V,E>, V]; void; null; graph.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g.vertexSet()>
<java.util.Set; size[]; int; org.jgrapht.alg.HamiltonianCycle; getApproximateOptimalForCompleteGraph[org.jgrapht.graph.SimpleWeightedGraph<V,E>]; java.util.List<V>; null; g.edgeSet()>
<java.util.Set; contains[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; containsVertex[V]; boolean; null; specifics.getVertexSet()>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; removeVertex[V]; boolean; null; specifics.getVertexSet()>


Calls That Broken Confinement (3)

<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes.get(i).outgoingArcs>
<java.util.List; add[org.jgrapht.alg.EdmondsKarpMaximumFlow<V,E>.Arc]; boolean; org.jgrapht.alg.EdmondsKarpMaximumFlow; buildInternalNetwork[]; void; null; nodes.get(j).outgoingArcs>
<java.util.Set; remove[java.lang.Object]; boolean; org.jgrapht.graph.AbstractBaseGraph; removeVertex[V]; boolean; null; specifics.getVertexSet()>
